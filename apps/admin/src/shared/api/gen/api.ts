/* tslint:disable */
/* eslint-disable */
/**
 * Spacelab Learning App For Managers
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  // setApiKeyToObject,
  // setBasicAuthToObject,
  setBearerAuthToObject,
  // setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  // RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface ApplicationChangeDataUser
 */
export interface ApplicationChangeDataUser {
  /**
   *
   * @type {number}
   * @memberof ApplicationChangeDataUser
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'lastName'?: string
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'middleName'?: string
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'email'?: string
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'birthday'?: string
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'work'?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationChangeDataUser
   */
  'education'?: Array<string>
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'englishLevel'?: ApplicationChangeDataUserEnglishLevelEnum
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'currentSituation'?: ApplicationChangeDataUserCurrentSituationEnum
  /**
   *
   * @type {Student}
   * @memberof ApplicationChangeDataUser
   */
  'student'?: Student
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'edit_time'?: string
  /**
   *
   * @type {string}
   * @memberof ApplicationChangeDataUser
   */
  'statusApplicationChangeDataUser'?: ApplicationChangeDataUserStatusApplicationChangeDataUserEnum
}

export const ApplicationChangeDataUserEnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const

export type ApplicationChangeDataUserEnglishLevelEnum =
  (typeof ApplicationChangeDataUserEnglishLevelEnum)[keyof typeof ApplicationChangeDataUserEnglishLevelEnum]
export const ApplicationChangeDataUserCurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const

export type ApplicationChangeDataUserCurrentSituationEnum =
  (typeof ApplicationChangeDataUserCurrentSituationEnum)[keyof typeof ApplicationChangeDataUserCurrentSituationEnum]
export const ApplicationChangeDataUserStatusApplicationChangeDataUserEnum = {
  Accepted: 'ACCEPTED',
  Rejected: 'REJECTED',
  Denied: 'DENIED',
  Canceled: 'CANCELED',
} as const

export type ApplicationChangeDataUserStatusApplicationChangeDataUserEnum =
  (typeof ApplicationChangeDataUserStatusApplicationChangeDataUserEnum)[keyof typeof ApplicationChangeDataUserStatusApplicationChangeDataUserEnum]

/**
 *
 * @export
 * @interface ApplicationStatusDto
 */
export interface ApplicationStatusDto {
  /**
   *
   * @type {number}
   * @memberof ApplicationStatusDto
   */
  'id'?: number
  /**
   *
   * @type {boolean}
   * @memberof ApplicationStatusDto
   */
  'status'?: boolean
}
/**
 *
 * @export
 * @interface Contact
 */
export interface Contact {
  /**
   *
   * @type {number}
   * @memberof Contact
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'lastName'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'middleName'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'email'?: string
  /**
   *
   * @type {boolean}
   * @memberof Contact
   */
  'isStudent'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Contact
   */
  'display'?: boolean
}
/**
 *
 * @export
 * @interface ContactDto
 */
export interface ContactDto {
  /**
   *
   * @type {string}
   * @memberof ContactDto
   */
  'name': string
  /**
   *
   * @type {string}
   * @memberof ContactDto
   */
  'lastName': string
  /**
   *
   * @type {string}
   * @memberof ContactDto
   */
  'middleName': string
  /**
   *
   * @type {string}
   * @memberof ContactDto
   */
  'telegram': string
  /**
   *
   * @type {string}
   * @memberof ContactDto
   */
  'telephone': string
  /**
   *
   * @type {string}
   * @memberof ContactDto
   */
  'email': string
  /**
   *
   * @type {boolean}
   * @memberof ContactDto
   */
  'display': boolean
}
/**
 *
 * @export
 * @interface ContactDtoForFilter
 */
export interface ContactDtoForFilter {
  /**
   *
   * @type {number}
   * @memberof ContactDtoForFilter
   */
  'page'?: number
  /**
   *
   * @type {number}
   * @memberof ContactDtoForFilter
   */
  'pageSize'?: number
  /**
   *
   * @type {string}
   * @memberof ContactDtoForFilter
   */
  'fullname'?: string
  /**
   *
   * @type {string}
   * @memberof ContactDtoForFilter
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof ContactDtoForFilter
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof ContactDtoForFilter
   */
  'email'?: string
}
/**
 *
 * @export
 * @interface Course
 */
export interface Course {
  /**
   *
   * @type {number}
   * @memberof Course
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Course
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Course
   */
  'status'?: CourseStatusEnum
  /**
   *
   * @type {Array<Literature>}
   * @memberof Course
   */
  'literature'?: Array<Literature>
  /**
   *
   * @type {Array<Task>}
   * @memberof Course
   */
  'tasks'?: Array<Task>
  /**
   *
   * @type {Array<Student>}
   * @memberof Course
   */
  'students'?: Array<Student>
  /**
   *
   * @type {Manager}
   * @memberof Course
   */
  'manager'?: Manager
  /**
   *
   * @type {Manager}
   * @memberof Course
   */
  'mentor'?: Manager
}

export const CourseStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Recruiting: 'RECRUITING',
} as const

export type CourseStatusEnum =
  (typeof CourseStatusEnum)[keyof typeof CourseStatusEnum]

/**
 * CourseDto for the add object page
 * @export
 * @interface CourseDtoForAdd
 */
export interface CourseDtoForAdd {
  /**
   *
   * @type {string}
   * @memberof CourseDtoForAdd
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof CourseDtoForAdd
   */
  'status': CourseDtoForAddStatusEnum
  /**
   *
   * @type {number}
   * @memberof CourseDtoForAdd
   */
  'mentorId': number
  /**
   *
   * @type {number}
   * @memberof CourseDtoForAdd
   */
  'managerId': number
}

export const CourseDtoForAddStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Recruiting: 'RECRUITING',
} as const

export type CourseDtoForAddStatusEnum =
  (typeof CourseDtoForAddStatusEnum)[keyof typeof CourseDtoForAddStatusEnum]

/**
 * CourseDto for the add object page
 * @export
 * @interface CourseDtoForEdit
 */
export interface CourseDtoForEdit {
  /**
   *
   * @type {number}
   * @memberof CourseDtoForEdit
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof CourseDtoForEdit
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof CourseDtoForEdit
   */
  'status'?: CourseDtoForEditStatusEnum
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CourseDtoForEdit
   */
  'mentor'?: { [key: string]: string }
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CourseDtoForEdit
   */
  'manager'?: { [key: string]: string }
}

export const CourseDtoForEditStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Recruiting: 'RECRUITING',
} as const

export type CourseDtoForEditStatusEnum =
  (typeof CourseDtoForEditStatusEnum)[keyof typeof CourseDtoForEditStatusEnum]

/**
 * CourseDto for the page where all courses are displayed or where some courses is displayed
 * @export
 * @interface CourseDtoForViewAndCard
 */
export interface CourseDtoForViewAndCard {
  /**
   *
   * @type {number}
   * @memberof CourseDtoForViewAndCard
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof CourseDtoForViewAndCard
   */
  'name'?: string
  /**
   *
   * @type {number}
   * @memberof CourseDtoForViewAndCard
   */
  'numberOfStudents'?: number
  /**
   *
   * @type {number}
   * @memberof CourseDtoForViewAndCard
   */
  'numberOfTasks'?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CourseDtoForViewAndCard
   */
  'mentor'?: { [key: string]: string }
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CourseDtoForViewAndCard
   */
  'manager'?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof CourseDtoForViewAndCard
   */
  'status'?: CourseDtoForViewAndCardStatusEnum
}

export const CourseDtoForViewAndCardStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Recruiting: 'RECRUITING',
} as const

export type CourseDtoForViewAndCardStatusEnum =
  (typeof CourseDtoForViewAndCardStatusEnum)[keyof typeof CourseDtoForViewAndCardStatusEnum]

/**
 * CourseDto to filter data
 * @export
 * @interface CourseDtoFotFilter
 */
export interface CourseDtoFotFilter {
  /**
   *
   * @type {number}
   * @memberof CourseDtoFotFilter
   */
  'page': number
  /**
   *
   * @type {number}
   * @memberof CourseDtoFotFilter
   */
  'pageSize': number
  /**
   *
   * @type {string}
   * @memberof CourseDtoFotFilter
   */
  'name'?: string
  /**
   *
   * @type {number}
   * @memberof CourseDtoFotFilter
   */
  'numberOfStudents'?: number
  /**
   *
   * @type {number}
   * @memberof CourseDtoFotFilter
   */
  'numberOfTasks'?: number
  /**
   *
   * @type {number}
   * @memberof CourseDtoFotFilter
   */
  'mentorId'?: number
  /**
   *
   * @type {number}
   * @memberof CourseDtoFotFilter
   */
  'managerId'?: number
  /**
   *
   * @type {string}
   * @memberof CourseDtoFotFilter
   */
  'status'?: CourseDtoFotFilterStatusEnum
}

export const CourseDtoFotFilterStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Recruiting: 'RECRUITING',
} as const

export type CourseDtoFotFilterStatusEnum =
  (typeof CourseDtoFotFilterStatusEnum)[keyof typeof CourseDtoFotFilterStatusEnum]

/**
 *
 * @export
 * @interface JwtRequest
 */
export interface JwtRequest {
  /**
   * email
   * @type {string}
   * @memberof JwtRequest
   */
  'username'?: string
  /**
   * password
   * @type {string}
   * @memberof JwtRequest
   */
  'password'?: string
}
/**
 *
 * @export
 * @interface JwtResponse
 */
export interface JwtResponse {
  /**
   *
   * @type {string}
   * @memberof JwtResponse
   */
  'accessToken'?: string
  /**
   *
   * @type {string}
   * @memberof JwtResponse
   */
  'refreshToken'?: string
}
/**
 *
 * @export
 * @interface Lesson
 */
export interface Lesson {
  /**
   *
   * @type {number}
   * @memberof Lesson
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Lesson
   */
  'date'?: string
  /**
   *
   * @type {string}
   * @memberof Lesson
   */
  'status'?: LessonStatusEnum
  /**
   *
   * @type {string}
   * @memberof Lesson
   */
  'link'?: string
  /**
   *
   * @type {LocalTime}
   * @memberof Lesson
   */
  'durationLesson'?: LocalTime
  /**
   *
   * @type {Course}
   * @memberof Lesson
   */
  'course'?: Course
  /**
   *
   * @type {boolean}
   * @memberof Lesson
   */
  'enableEdit'?: boolean
  /**
   *
   * @type {string}
   * @memberof Lesson
   */
  'timeLastEdit'?: string
  /**
   *
   * @type {Array<Review>}
   * @memberof Lesson
   */
  'reviews'?: Array<Review>
}

export const LessonStatusEnum = {
  Active: 'ACTIVE',
  Finished: 'FINISHED',
} as const

export type LessonStatusEnum =
  (typeof LessonStatusEnum)[keyof typeof LessonStatusEnum]

/**
 *
 * @export
 * @interface LessonDtoEnd
 */
export interface LessonDtoEnd {
  /**
   *
   * @type {number}
   * @memberof LessonDtoEnd
   */
  'id': number
  /**
   *
   * @type {Array<ReviewDto>}
   * @memberof LessonDtoEnd
   */
  'reviews': Array<ReviewDto>
}
/**
 *
 * @export
 * @interface LessonDtoForFilter
 */
export interface LessonDtoForFilter {
  /**
   *
   * @type {number}
   * @memberof LessonDtoForFilter
   */
  'page': number
  /**
   *
   * @type {number}
   * @memberof LessonDtoForFilter
   */
  'pageSize': number
  /**
   *
   * @type {string}
   * @memberof LessonDtoForFilter
   */
  'startLesson'?: string
  /**
   *
   * @type {string}
   * @memberof LessonDtoForFilter
   */
  'endLesson'?: string
  /**
   *
   * @type {number}
   * @memberof LessonDtoForFilter
   */
  'quantityStudents'?: number
  /**
   *
   * @type {number}
   * @memberof LessonDtoForFilter
   */
  'courseId'?: number
  /**
   *
   * @type {number}
   * @memberof LessonDtoForFilter
   */
  'mentorId'?: number
  /**
   *
   * @type {string}
   * @memberof LessonDtoForFilter
   */
  'statusLesson'?: LessonDtoForFilterStatusLessonEnum
}

export const LessonDtoForFilterStatusLessonEnum = {
  Active: 'ACTIVE',
  Finished: 'FINISHED',
} as const

export type LessonDtoForFilterStatusLessonEnum =
  (typeof LessonDtoForFilterStatusLessonEnum)[keyof typeof LessonDtoForFilterStatusLessonEnum]

/**
 *
 * @export
 * @interface Literature
 */
export interface Literature {
  /**
   *
   * @type {number}
   * @memberof Literature
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Literature
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Literature
   */
  'linkForDownload'?: string
  /**
   *
   * @type {string}
   * @memberof Literature
   */
  'typeLiterature'?: LiteratureTypeLiteratureEnum
  /**
   *
   * @type {Array<string>}
   * @memberof Literature
   */
  'keyWords'?: Array<string>
}

export const LiteratureTypeLiteratureEnum = {
  Book: 'BOOK',
  Link: 'LINK',
} as const

export type LiteratureTypeLiteratureEnum =
  (typeof LiteratureTypeLiteratureEnum)[keyof typeof LiteratureTypeLiteratureEnum]

/**
 *
 * @export
 * @interface LiteratureDtoForFilter
 */
export interface LiteratureDtoForFilter {
  /**
   *
   * @type {number}
   * @memberof LiteratureDtoForFilter
   */
  'page'?: number
  /**
   *
   * @type {number}
   * @memberof LiteratureDtoForFilter
   */
  'pageSize'?: number
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForFilter
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForFilter
   */
  'typeLiterature'?: LiteratureDtoForFilterTypeLiteratureEnum
  /**
   *
   * @type {number}
   * @memberof LiteratureDtoForFilter
   */
  'courseId'?: number
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForFilter
   */
  'keyword'?: string
}

export const LiteratureDtoForFilterTypeLiteratureEnum = {
  Book: 'BOOK',
  Link: 'LINK',
} as const

export type LiteratureDtoForFilterTypeLiteratureEnum =
  (typeof LiteratureDtoForFilterTypeLiteratureEnum)[keyof typeof LiteratureDtoForFilterTypeLiteratureEnum]

/**
 *
 * @export
 * @interface LiteratureDtoForView
 */
export interface LiteratureDtoForView {
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForView
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForView
   */
  'linkForDownload'?: string
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForView
   */
  'typeLiterature'?: LiteratureDtoForViewTypeLiteratureEnum
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForView
   */
  'course'?: string
  /**
   *
   * @type {Array<string>}
   * @memberof LiteratureDtoForView
   */
  'keyWords'?: Array<string>
}

export const LiteratureDtoForViewTypeLiteratureEnum = {
  Book: 'BOOK',
  Link: 'LINK',
} as const

export type LiteratureDtoForViewTypeLiteratureEnum =
  (typeof LiteratureDtoForViewTypeLiteratureEnum)[keyof typeof LiteratureDtoForViewTypeLiteratureEnum]

/**
 *
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  'hour'?: number
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  'minute'?: number
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  'second'?: number
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  'nano'?: number
}
/**
 *
 * @export
 * @interface Manager
 */
export interface Manager {
  /**
   *
   * @type {number}
   * @memberof Manager
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  'image'?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  'email'?: string
  /**
   *
   * @type {number}
   * @memberof Manager
   */
  'pageSize'?: number
  /**
   *
   * @type {boolean}
   * @memberof Manager
   */
  'themeIsDark'?: boolean
  /**
   *
   * @type {Contact}
   * @memberof Manager
   */
  'contact'?: Contact
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  'status'?: ManagerStatusEnum
  /**
   *
   * @type {Array<Course>}
   * @memberof Manager
   */
  'coursesByManager'?: Array<Course>
  /**
   *
   * @type {Array<Course>}
   * @memberof Manager
   */
  'coursesByMentor'?: Array<Course>
  /**
   *
   * @type {Array<Course>}
   * @memberof Manager
   */
  'courses'?: Array<Course>
  /**
   *
   * @type {Role}
   * @memberof Manager
   */
  'role'?: Role
}

export const ManagerStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const

export type ManagerStatusEnum =
  (typeof ManagerStatusEnum)[keyof typeof ManagerStatusEnum]

/**
 * ManagerDto for the add object page
 * @export
 * @interface ManagerDtoForAdd
 */
export interface ManagerDtoForAdd {
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForAdd
   */
  'name': string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForAdd
   */
  'lastName': string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForAdd
   */
  'middleName': string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForAdd
   */
  'password'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForAdd
   */
  'telegram': string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForAdd
   */
  'telephone': string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForAdd
   */
  'email': string
  /**
   *
   * @type {File}
   * @memberof ManagerDtoForAdd
   */
  'image'?: File
  /**
   *
   * @type {Array<number>}
   * @memberof ManagerDtoForAdd
   */
  'courseId'?: Array<number>
  /**
   *
   * @type {number}
   * @memberof ManagerDtoForAdd
   */
  'roleId': number
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForAdd
   */
  'status': ManagerDtoForAddStatusEnum
  /**
   *
   * @type {boolean}
   * @memberof ManagerDtoForAdd
   */
  'display'?: boolean
}

export const ManagerDtoForAddStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const

export type ManagerDtoForAddStatusEnum =
  (typeof ManagerDtoForAddStatusEnum)[keyof typeof ManagerDtoForAddStatusEnum]

/**
 * ManagerDto for the page where some manager is displayed
 * @export
 * @interface ManagerDtoForCard
 */
export interface ManagerDtoForCard {
  /**
   *
   * @type {number}
   * @memberof ManagerDtoForCard
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForCard
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForCard
   */
  'lastName'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForCard
   */
  'middleName'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForCard
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForCard
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForCard
   */
  'email'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForCard
   */
  'image'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForCard
   */
  'status'?: ManagerDtoForCardStatusEnum
  /**
   *
   * @type {Role}
   * @memberof ManagerDtoForCard
   */
  'role'?: Role
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ManagerDtoForCard
   */
  'courses'?: { [key: string]: string }
}

export const ManagerDtoForCardStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const

export type ManagerDtoForCardStatusEnum =
  (typeof ManagerDtoForCardStatusEnum)[keyof typeof ManagerDtoForCardStatusEnum]

/**
 * ManagerDto to filter data
 * @export
 * @interface ManagerDtoForFilter
 */
export interface ManagerDtoForFilter {
  /**
   *
   * @type {number}
   * @memberof ManagerDtoForFilter
   */
  'page': number
  /**
   *
   * @type {number}
   * @memberof ManagerDtoForFilter
   */
  'pageSize': number
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForFilter
   */
  'fullName'?: string
  /**
   *
   * @type {number}
   * @memberof ManagerDtoForFilter
   */
  'courseId'?: number
  /**
   *
   * @type {number}
   * @memberof ManagerDtoForFilter
   */
  'roleId'?: number
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForFilter
   */
  'statusManager'?: ManagerDtoForFilterStatusManagerEnum
}

export const ManagerDtoForFilterStatusManagerEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const

export type ManagerDtoForFilterStatusManagerEnum =
  (typeof ManagerDtoForFilterStatusManagerEnum)[keyof typeof ManagerDtoForFilterStatusManagerEnum]

/**
 * ManagerDto for the page where all managers are displayed
 * @export
 * @interface ManagerDtoForView
 */
export interface ManagerDtoForView {
  /**
   *
   * @type {number}
   * @memberof ManagerDtoForView
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForView
   */
  'fullName'?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ManagerDtoForView
   */
  'courses'?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForView
   */
  'role'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForView
   */
  'status'?: ManagerDtoForViewStatusEnum
}

export const ManagerDtoForViewStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const

export type ManagerDtoForViewStatusEnum =
  (typeof ManagerDtoForViewStatusEnum)[keyof typeof ManagerDtoForViewStatusEnum]

/**
 *
 * @export
 * @interface PageApplicationChangeDataUser
 */
export interface PageApplicationChangeDataUser {
  /**
   *
   * @type {number}
   * @memberof PageApplicationChangeDataUser
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageApplicationChangeDataUser
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageApplicationChangeDataUser
   */
  'size'?: number
  /**
   *
   * @type {Array<ApplicationChangeDataUser>}
   * @memberof PageApplicationChangeDataUser
   */
  'content'?: Array<ApplicationChangeDataUser>
  /**
   *
   * @type {number}
   * @memberof PageApplicationChangeDataUser
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageApplicationChangeDataUser
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageApplicationChangeDataUser
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageApplicationChangeDataUser
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageApplicationChangeDataUser
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageApplicationChangeDataUser
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageApplicationChangeDataUser
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageContactDto
 */
export interface PageContactDto {
  /**
   *
   * @type {number}
   * @memberof PageContactDto
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageContactDto
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageContactDto
   */
  'size'?: number
  /**
   *
   * @type {Array<ContactDto>}
   * @memberof PageContactDto
   */
  'content'?: Array<ContactDto>
  /**
   *
   * @type {number}
   * @memberof PageContactDto
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageContactDto
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageContactDto
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageContactDto
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageContactDto
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageContactDto
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageContactDto
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageCourseDtoForViewAndCard
 */
export interface PageCourseDtoForViewAndCard {
  /**
   *
   * @type {number}
   * @memberof PageCourseDtoForViewAndCard
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageCourseDtoForViewAndCard
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageCourseDtoForViewAndCard
   */
  'size'?: number
  /**
   *
   * @type {Array<CourseDtoForViewAndCard>}
   * @memberof PageCourseDtoForViewAndCard
   */
  'content'?: Array<CourseDtoForViewAndCard>
  /**
   *
   * @type {number}
   * @memberof PageCourseDtoForViewAndCard
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageCourseDtoForViewAndCard
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageCourseDtoForViewAndCard
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageCourseDtoForViewAndCard
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageCourseDtoForViewAndCard
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageCourseDtoForViewAndCard
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageCourseDtoForViewAndCard
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageLiteratureDtoForView
 */
export interface PageLiteratureDtoForView {
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'size'?: number
  /**
   *
   * @type {Array<LiteratureDtoForView>}
   * @memberof PageLiteratureDtoForView
   */
  'content'?: Array<LiteratureDtoForView>
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageLiteratureDtoForView
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageLiteratureDtoForView
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageLiteratureDtoForView
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageLiteratureDtoForView
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageLiteratureDtoForView
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageManagerDtoForView
 */
export interface PageManagerDtoForView {
  /**
   *
   * @type {number}
   * @memberof PageManagerDtoForView
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageManagerDtoForView
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageManagerDtoForView
   */
  'size'?: number
  /**
   *
   * @type {Array<ManagerDtoForView>}
   * @memberof PageManagerDtoForView
   */
  'content'?: Array<ManagerDtoForView>
  /**
   *
   * @type {number}
   * @memberof PageManagerDtoForView
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageManagerDtoForView
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageManagerDtoForView
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageManagerDtoForView
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageManagerDtoForView
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageManagerDtoForView
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageManagerDtoForView
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageRoleDtoView
 */
export interface PageRoleDtoView {
  /**
   *
   * @type {number}
   * @memberof PageRoleDtoView
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageRoleDtoView
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageRoleDtoView
   */
  'size'?: number
  /**
   *
   * @type {Array<RoleDtoView>}
   * @memberof PageRoleDtoView
   */
  'content'?: Array<RoleDtoView>
  /**
   *
   * @type {number}
   * @memberof PageRoleDtoView
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageRoleDtoView
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageRoleDtoView
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageRoleDtoView
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageRoleDtoView
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageRoleDtoView
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageRoleDtoView
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageStudentDtoForStatistic
 */
export interface PageStudentDtoForStatistic {
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForStatistic
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForStatistic
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForStatistic
   */
  'size'?: number
  /**
   *
   * @type {Array<StudentDtoForStatistic>}
   * @memberof PageStudentDtoForStatistic
   */
  'content'?: Array<StudentDtoForStatistic>
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForStatistic
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageStudentDtoForStatistic
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageStudentDtoForStatistic
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForStatistic
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageStudentDtoForStatistic
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageStudentDtoForStatistic
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageStudentDtoForStatistic
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageStudentDtoForView
 */
export interface PageStudentDtoForView {
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForView
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForView
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForView
   */
  'size'?: number
  /**
   *
   * @type {Array<StudentDtoForView>}
   * @memberof PageStudentDtoForView
   */
  'content'?: Array<StudentDtoForView>
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForView
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageStudentDtoForView
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageStudentDtoForView
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageStudentDtoForView
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageStudentDtoForView
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageStudentDtoForView
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageStudentDtoForView
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageTaskDtoForView
 */
export interface PageTaskDtoForView {
  /**
   *
   * @type {number}
   * @memberof PageTaskDtoForView
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageTaskDtoForView
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageTaskDtoForView
   */
  'size'?: number
  /**
   *
   * @type {Array<TaskDtoForView>}
   * @memberof PageTaskDtoForView
   */
  'content'?: Array<TaskDtoForView>
  /**
   *
   * @type {number}
   * @memberof PageTaskDtoForView
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageTaskDtoForView
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageTaskDtoForView
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageTaskDtoForView
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageTaskDtoForView
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageTaskDtoForView
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageTaskDtoForView
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  'offset'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageableObject
   */
  'sort'?: SortObject
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  'pageNumber'?: number
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  'pageSize'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageableObject
   */
  'paged'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageableObject
   */
  'unpaged'?: boolean
}
/**
 *
 * @export
 * @interface Review
 */
export interface Review {
  /**
   *
   * @type {number}
   * @memberof Review
   */
  'id'?: number
  /**
   *
   * @type {boolean}
   * @memberof Review
   */
  'isPresent'?: boolean
  /**
   *
   * @type {string}
   * @memberof Review
   */
  'reason'?: string
  /**
   *
   * @type {number}
   * @memberof Review
   */
  'hours'?: number
  /**
   *
   * @type {number}
   * @memberof Review
   */
  'grade'?: number
  /**
   *
   * @type {string}
   * @memberof Review
   */
  'comment'?: string
  /**
   *
   * @type {Student}
   * @memberof Review
   */
  'student'?: Student
}
/**
 *
 * @export
 * @interface ReviewDto
 */
export interface ReviewDto {
  /**
   *
   * @type {boolean}
   * @memberof ReviewDto
   */
  'isPresent': boolean
  /**
   *
   * @type {string}
   * @memberof ReviewDto
   */
  'reason'?: string
  /**
   *
   * @type {number}
   * @memberof ReviewDto
   */
  'hours': number
  /**
   *
   * @type {number}
   * @memberof ReviewDto
   */
  'grade': number
  /**
   *
   * @type {string}
   * @memberof ReviewDto
   */
  'comment': string
  /**
   *
   * @type {number}
   * @memberof ReviewDto
   */
  'studentId': number
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {number}
   * @memberof Role
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Role
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Role
   */
  'nameEng'?: string
  /**
   *
   * @type {string}
   * @memberof Role
   */
  'nameUkr'?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Role
   */
  'pages'?: Array<RolePagesEnum>
  /**
   *
   * @type {Array<Manager>}
   * @memberof Role
   */
  'managers'?: Array<Manager>
}

export const RolePagesEnum = {
  Statistic: 'STATISTIC',
  Task: 'TASK',
  Student: 'STUDENT',
  Course: 'COURSE',
  Lesson: 'LESSON',
  Literature: 'LITERATURE',
  Role: 'ROLE',
  Test: 'TEST',
  Contact: 'CONTACT',
} as const

export type RolePagesEnum = (typeof RolePagesEnum)[keyof typeof RolePagesEnum]

/**
 * RoleDtoFilter for the Role page where all Roles are displayed
 * @export
 * @interface RoleDtoFilter
 */
export interface RoleDtoFilter {
  /**
   *
   * @type {number}
   * @memberof RoleDtoFilter
   */
  'page'?: number
  /**
   *
   * @type {number}
   * @memberof RoleDtoFilter
   */
  'pageSize'?: number
  /**
   *
   * @type {Array<number>}
   * @memberof RoleDtoFilter
   */
  'managers'?: Array<number>
  /**
   *
   * @type {Array<string>}
   * @memberof RoleDtoFilter
   */
  'pages'?: Array<RoleDtoFilterPagesEnum>
  /**
   *
   * @type {string}
   * @memberof RoleDtoFilter
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof RoleDtoFilter
   */
  'nameEng'?: string
  /**
   *
   * @type {string}
   * @memberof RoleDtoFilter
   */
  'nameUkr'?: string
}

export const RoleDtoFilterPagesEnum = {
  Statistic: 'STATISTIC',
  Task: 'TASK',
  Student: 'STUDENT',
  Course: 'COURSE',
  Lesson: 'LESSON',
  Literature: 'LITERATURE',
  Role: 'ROLE',
  Test: 'TEST',
  Contact: 'CONTACT',
} as const

export type RoleDtoFilterPagesEnum =
  (typeof RoleDtoFilterPagesEnum)[keyof typeof RoleDtoFilterPagesEnum]

/**
 * RoleDtoView for search object page
 * @export
 * @interface RoleDtoView
 */
export interface RoleDtoView {
  /**
   *
   * @type {number}
   * @memberof RoleDtoView
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof RoleDtoView
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof RoleDtoView
   */
  'nameEng'?: string
  /**
   *
   * @type {string}
   * @memberof RoleDtoView
   */
  'nameUkr'?: string
  /**
   *
   * @type {Array<string>}
   * @memberof RoleDtoView
   */
  'pages'?: Array<RoleDtoViewPagesEnum>
  /**
   *
   * @type {Array<string>}
   * @memberof RoleDtoView
   */
  'managers'?: Array<string>
}

export const RoleDtoViewPagesEnum = {
  Statistic: 'STATISTIC',
  Task: 'TASK',
  Student: 'STUDENT',
  Course: 'COURSE',
  Lesson: 'LESSON',
  Literature: 'LITERATURE',
  Role: 'ROLE',
  Test: 'TEST',
  Contact: 'CONTACT',
} as const

export type RoleDtoViewPagesEnum =
  (typeof RoleDtoViewPagesEnum)[keyof typeof RoleDtoViewPagesEnum]

/**
 *
 * @export
 * @interface SortObject
 */
export interface SortObject {
  /**
   *
   * @type {boolean}
   * @memberof SortObject
   */
  'empty'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof SortObject
   */
  'sorted'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof SortObject
   */
  'unsorted'?: boolean
}
/**
 *
 * @export
 * @interface Student
 */
export interface Student {
  /**
   *
   * @type {number}
   * @memberof Student
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'image'?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'email'?: string
  /**
   *
   * @type {number}
   * @memberof Student
   */
  'pageSize'?: number
  /**
   *
   * @type {boolean}
   * @memberof Student
   */
  'themeIsDark'?: boolean
  /**
   *
   * @type {Contact}
   * @memberof Student
   */
  'contact'?: Contact
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'status'?: StudentStatusEnum
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'levelOfPreparation'?: StudentLevelOfPreparationEnum
  /**
   *
   * @type {boolean}
   * @memberof Student
   */
  'isVideoReview'?: boolean
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'birthday'?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'work'?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Student
   */
  'education'?: Array<string>
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'englishLevel'?: StudentEnglishLevelEnum
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'currentSituation'?: StudentCurrentSituationEnum
  /**
   *
   * @type {number}
   * @memberof Student
   */
  'totalMark'?: number
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'dateOfJoining'?: string
  /**
   *
   * @type {Array<StudentTask>}
   * @memberof Student
   */
  'tasks'?: Array<StudentTask>
  /**
   *
   * @type {Course}
   * @memberof Student
   */
  'course'?: Course
  /**
   *
   * @type {Array<StudentMemento>}
   * @memberof Student
   */
  'studentMementos'?: Array<StudentMemento>
  /**
   *
   * @type {Array<ApplicationChangeDataUser>}
   * @memberof Student
   */
  'applicationChangeDataUser'?: Array<ApplicationChangeDataUser>
}

export const StudentStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const

export type StudentStatusEnum =
  (typeof StudentStatusEnum)[keyof typeof StudentStatusEnum]
export const StudentLevelOfPreparationEnum = {
  NoSkills: 'NO_SKILLS',
  BadSkills: 'BAD_SKILLS',
  GoodSkills: 'GOOD_SKILLS',
  Ready: 'READY',
} as const

export type StudentLevelOfPreparationEnum =
  (typeof StudentLevelOfPreparationEnum)[keyof typeof StudentLevelOfPreparationEnum]
export const StudentEnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const

export type StudentEnglishLevelEnum =
  (typeof StudentEnglishLevelEnum)[keyof typeof StudentEnglishLevelEnum]
export const StudentCurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const

export type StudentCurrentSituationEnum =
  (typeof StudentCurrentSituationEnum)[keyof typeof StudentCurrentSituationEnum]

/**
 * StudentDto for the add object page
 * @export
 * @interface StudentDtoForAdd
 */
export interface StudentDtoForAdd {
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'lastName'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'middleName'?: string
  /**
   *
   * @type {boolean}
   * @memberof StudentDtoForAdd
   */
  'isVideoReview'?: boolean
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'email': string
  /**
   *
   * @type {File}
   * @memberof StudentDtoForAdd
   */
  'image'?: File
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'oldImageName'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'birthday'?: string
  /**
   *
   * @type {number}
   * @memberof StudentDtoForAdd
   */
  'totalMark'?: number
  /**
   *
   * @type {Array<string>}
   * @memberof StudentDtoForAdd
   */
  'education'?: Array<string>
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'currentSituation'?: StudentDtoForAddCurrentSituationEnum
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'levelOfPreparation'?: StudentDtoForAddLevelOfPreparationEnum
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'englishLevel'?: StudentDtoForAddEnglishLevelEnum
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'status'?: StudentDtoForAddStatusEnum
  /**
   *
   * @type {number}
   * @memberof StudentDtoForAdd
   */
  'courseId'?: number
  /**
   *
   * @type {string}
   * @memberof StudentDtoForAdd
   */
  'work'?: string
  /**
   *
   * @type {boolean}
   * @memberof StudentDtoForAdd
   */
  'display'?: boolean
}

export const StudentDtoForAddCurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const

export type StudentDtoForAddCurrentSituationEnum =
  (typeof StudentDtoForAddCurrentSituationEnum)[keyof typeof StudentDtoForAddCurrentSituationEnum]
export const StudentDtoForAddLevelOfPreparationEnum = {
  NoSkills: 'NO_SKILLS',
  BadSkills: 'BAD_SKILLS',
  GoodSkills: 'GOOD_SKILLS',
  Ready: 'READY',
} as const

export type StudentDtoForAddLevelOfPreparationEnum =
  (typeof StudentDtoForAddLevelOfPreparationEnum)[keyof typeof StudentDtoForAddLevelOfPreparationEnum]
export const StudentDtoForAddEnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const

export type StudentDtoForAddEnglishLevelEnum =
  (typeof StudentDtoForAddEnglishLevelEnum)[keyof typeof StudentDtoForAddEnglishLevelEnum]
export const StudentDtoForAddStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const

export type StudentDtoForAddStatusEnum =
  (typeof StudentDtoForAddStatusEnum)[keyof typeof StudentDtoForAddStatusEnum]

/**
 * StudentDto for the page where some student is displayed
 * @export
 * @interface StudentDtoForCard
 */
export interface StudentDtoForCard {
  /**
   *
   * @type {number}
   * @memberof StudentDtoForCard
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'lastName'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'middleName'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'email'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'image'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'status'?: StudentDtoForCardStatusEnum
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof StudentDtoForCard
   */
  'course'?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'birthday'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'levelOfPreparation'?: StudentDtoForCardLevelOfPreparationEnum
  /**
   *
   * @type {Array<string>}
   * @memberof StudentDtoForCard
   */
  'education'?: Array<string>
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'currentSituation'?: StudentDtoForCardCurrentSituationEnum
  /**
   *
   * @type {string}
   * @memberof StudentDtoForCard
   */
  'englishLevel'?: StudentDtoForCardEnglishLevelEnum
}

export const StudentDtoForCardStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const

export type StudentDtoForCardStatusEnum =
  (typeof StudentDtoForCardStatusEnum)[keyof typeof StudentDtoForCardStatusEnum]
export const StudentDtoForCardLevelOfPreparationEnum = {
  NoSkills: 'NO_SKILLS',
  BadSkills: 'BAD_SKILLS',
  GoodSkills: 'GOOD_SKILLS',
  Ready: 'READY',
} as const

export type StudentDtoForCardLevelOfPreparationEnum =
  (typeof StudentDtoForCardLevelOfPreparationEnum)[keyof typeof StudentDtoForCardLevelOfPreparationEnum]
export const StudentDtoForCardCurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const

export type StudentDtoForCardCurrentSituationEnum =
  (typeof StudentDtoForCardCurrentSituationEnum)[keyof typeof StudentDtoForCardCurrentSituationEnum]
export const StudentDtoForCardEnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const

export type StudentDtoForCardEnglishLevelEnum =
  (typeof StudentDtoForCardEnglishLevelEnum)[keyof typeof StudentDtoForCardEnglishLevelEnum]

/**
 * StudentDto to filter data
 * @export
 * @interface StudentDtoForFilter
 */
export interface StudentDtoForFilter {
  /**
   *
   * @type {number}
   * @memberof StudentDtoForFilter
   */
  'page': number
  /**
   *
   * @type {number}
   * @memberof StudentDtoForFilter
   */
  'pageSize': number
  /**
   *
   * @type {string}
   * @memberof StudentDtoForFilter
   */
  'fullName'?: string
  /**
   *
   * @type {number}
   * @memberof StudentDtoForFilter
   */
  'courseId'?: number
  /**
   *
   * @type {string}
   * @memberof StudentDtoForFilter
   */
  'fromDate'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForFilter
   */
  'toDate'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForFilter
   */
  'levelOfPreparation'?: StudentDtoForFilterLevelOfPreparationEnum
  /**
   *
   * @type {number}
   * @memberof StudentDtoForFilter
   */
  'taskId'?: number
  /**
   *
   * @type {string}
   * @memberof StudentDtoForFilter
   */
  'status'?: StudentDtoForFilterStatusEnum
}

export const StudentDtoForFilterLevelOfPreparationEnum = {
  NoSkills: 'NO_SKILLS',
  BadSkills: 'BAD_SKILLS',
  GoodSkills: 'GOOD_SKILLS',
  Ready: 'READY',
} as const

export type StudentDtoForFilterLevelOfPreparationEnum =
  (typeof StudentDtoForFilterLevelOfPreparationEnum)[keyof typeof StudentDtoForFilterLevelOfPreparationEnum]
export const StudentDtoForFilterStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const

export type StudentDtoForFilterStatusEnum =
  (typeof StudentDtoForFilterStatusEnum)[keyof typeof StudentDtoForFilterStatusEnum]

/**
 * StudentDto to statistic Page
 * @export
 * @interface StudentDtoForStatistic
 */
export interface StudentDtoForStatistic {
  /**
   *
   * @type {number}
   * @memberof StudentDtoForStatistic
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof StudentDtoForStatistic
   */
  'fullName'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForStatistic
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForStatistic
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForStatistic
   */
  'status'?: StudentDtoForStatisticStatusEnum
  /**
   *
   * @type {number}
   * @memberof StudentDtoForStatistic
   */
  'totalMark'?: number
}

export const StudentDtoForStatisticStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const

export type StudentDtoForStatisticStatusEnum =
  (typeof StudentDtoForStatisticStatusEnum)[keyof typeof StudentDtoForStatisticStatusEnum]

/**
 * StudentDto for the page where all students are displayed
 * @export
 * @interface StudentDtoForView
 */
export interface StudentDtoForView {
  /**
   *
   * @type {number}
   * @memberof StudentDtoForView
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof StudentDtoForView
   */
  'fullName'?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof StudentDtoForView
   */
  'course'?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof StudentDtoForView
   */
  'dateOfJoining'?: string
  /**
   *
   * @type {string}
   * @memberof StudentDtoForView
   */
  'levelOfPreparation'?: StudentDtoForViewLevelOfPreparationEnum
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof StudentDtoForView
   */
  'task'?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof StudentDtoForView
   */
  'status'?: StudentDtoForViewStatusEnum
}

export const StudentDtoForViewLevelOfPreparationEnum = {
  NoSkills: 'NO_SKILLS',
  BadSkills: 'BAD_SKILLS',
  GoodSkills: 'GOOD_SKILLS',
  Ready: 'READY',
} as const

export type StudentDtoForViewLevelOfPreparationEnum =
  (typeof StudentDtoForViewLevelOfPreparationEnum)[keyof typeof StudentDtoForViewLevelOfPreparationEnum]
export const StudentDtoForViewStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const

export type StudentDtoForViewStatusEnum =
  (typeof StudentDtoForViewStatusEnum)[keyof typeof StudentDtoForViewStatusEnum]

/**
 *
 * @export
 * @interface StudentMemento
 */
export interface StudentMemento {
  /**
   *
   * @type {number}
   * @memberof StudentMemento
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'lastName'?: string
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'middleName'?: string
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'email'?: string
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'image'?: string
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'birthday'?: string
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'work'?: string
  /**
   *
   * @type {Array<string>}
   * @memberof StudentMemento
   */
  'education'?: Array<string>
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'englishLevel'?: StudentMementoEnglishLevelEnum
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'currentSituation'?: StudentMementoCurrentSituationEnum
  /**
   *
   * @type {Student}
   * @memberof StudentMemento
   */
  'student'?: Student
  /**
   *
   * @type {string}
   * @memberof StudentMemento
   */
  'edit_time'?: string
}

export const StudentMementoEnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const

export type StudentMementoEnglishLevelEnum =
  (typeof StudentMementoEnglishLevelEnum)[keyof typeof StudentMementoEnglishLevelEnum]
export const StudentMementoCurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const

export type StudentMementoCurrentSituationEnum =
  (typeof StudentMementoCurrentSituationEnum)[keyof typeof StudentMementoCurrentSituationEnum]

/**
 *
 * @export
 * @interface StudentTask
 */
export interface StudentTask {
  /**
   *
   * @type {number}
   * @memberof StudentTask
   */
  'id'?: number
  /**
   *
   * @type {Task}
   * @memberof StudentTask
   */
  'task'?: Task
  /**
   *
   * @type {string}
   * @memberof StudentTask
   */
  'status'?: StudentTaskStatusEnum
  /**
   *
   * @type {string}
   * @memberof StudentTask
   */
  'comment'?: string
  /**
   *
   * @type {string}
   * @memberof StudentTask
   */
  'finishDate'?: string
}

export const StudentTaskStatusEnum = {
  InProgress: 'IN_PROGRESS',
  Testing: 'TESTING',
  Done: 'DONE',
} as const

export type StudentTaskStatusEnum =
  (typeof StudentTaskStatusEnum)[keyof typeof StudentTaskStatusEnum]

/**
 * Dto for the page where all student\'s tasks are displayed
 * @export
 * @interface StudentTasksDto
 */
export interface StudentTasksDto {
  /**
   *
   * @type {number}
   * @memberof StudentTasksDto
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof StudentTasksDto
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof StudentTasksDto
   */
  'comment'?: string
  /**
   *
   * @type {string}
   * @memberof StudentTasksDto
   */
  'status'?: StudentTasksDtoStatusEnum
  /**
   *
   * @type {string}
   * @memberof StudentTasksDto
   */
  'finishDate'?: string
}

export const StudentTasksDtoStatusEnum = {
  InProgress: 'IN_PROGRESS',
  Testing: 'TESTING',
  Done: 'DONE',
} as const

export type StudentTasksDtoStatusEnum =
  (typeof StudentTasksDtoStatusEnum)[keyof typeof StudentTasksDtoStatusEnum]

/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   *
   * @type {number}
   * @memberof Task
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'aim'?: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'description'?: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'level'?: TaskLevelEnum
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'status'?: TaskStatusEnum
  /**
   *
   * @type {Course}
   * @memberof Task
   */
  'course'?: Course
  /**
   *
   * @type {Array<Task>}
   * @memberof Task
   */
  'subTasks'?: Array<Task>
}

export const TaskLevelEnum = {
  Easy: 'EASY',
  Middle: 'MIDDLE',
  Hard: 'HARD',
} as const

export type TaskLevelEnum = (typeof TaskLevelEnum)[keyof typeof TaskLevelEnum]
export const TaskStatusEnum = {
  Active: 'ACTIVE',
  NotActive: 'NOT_ACTIVE',
  BeingEdited: 'BEING_EDITED',
} as const

export type TaskStatusEnum =
  (typeof TaskStatusEnum)[keyof typeof TaskStatusEnum]

/**
 * TaskDto for the add object page
 * @export
 * @interface TaskDtoForAdd
 */
export interface TaskDtoForAdd {
  /**
   *
   * @type {string}
   * @memberof TaskDtoForAdd
   */
  'name'?: string
  /**
   *
   * @type {number}
   * @memberof TaskDtoForAdd
   */
  'courseId'?: number
  /**
   *
   * @type {string}
   * @memberof TaskDtoForAdd
   */
  'level'?: TaskDtoForAddLevelEnum
  /**
   *
   * @type {string}
   * @memberof TaskDtoForAdd
   */
  'aim'?: string
  /**
   *
   * @type {string}
   * @memberof TaskDtoForAdd
   */
  'description'?: string
  /**
   *
   * @type {Array<TaskDtoForAdd>}
   * @memberof TaskDtoForAdd
   */
  'subTasks'?: Array<TaskDtoForAdd>
}

export const TaskDtoForAddLevelEnum = {
  Easy: 'EASY',
  Middle: 'MIDDLE',
  Hard: 'HARD',
} as const

export type TaskDtoForAddLevelEnum =
  (typeof TaskDtoForAddLevelEnum)[keyof typeof TaskDtoForAddLevelEnum]

/**
 * TaskDto for the page where some student is displayed
 * @export
 * @interface TaskDtoForCard
 */
export interface TaskDtoForCard {
  /**
   *
   * @type {string}
   * @memberof TaskDtoForCard
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof TaskDtoForCard
   */
  'course'?: string
  /**
   *
   * @type {string}
   * @memberof TaskDtoForCard
   */
  'level'?: TaskDtoForCardLevelEnum
  /**
   *
   * @type {string}
   * @memberof TaskDtoForCard
   */
  'status'?: TaskDtoForCardStatusEnum
  /**
   *
   * @type {string}
   * @memberof TaskDtoForCard
   */
  'aim'?: string
  /**
   *
   * @type {string}
   * @memberof TaskDtoForCard
   */
  'description'?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof TaskDtoForCard
   */
  'tasks'?: { [key: string]: string }
}

export const TaskDtoForCardLevelEnum = {
  Easy: 'EASY',
  Middle: 'MIDDLE',
  Hard: 'HARD',
} as const

export type TaskDtoForCardLevelEnum =
  (typeof TaskDtoForCardLevelEnum)[keyof typeof TaskDtoForCardLevelEnum]
export const TaskDtoForCardStatusEnum = {
  Active: 'ACTIVE',
  NotActive: 'NOT_ACTIVE',
  BeingEdited: 'BEING_EDITED',
} as const

export type TaskDtoForCardStatusEnum =
  (typeof TaskDtoForCardStatusEnum)[keyof typeof TaskDtoForCardStatusEnum]

/**
 * TaskDto to filter data
 * @export
 * @interface TaskDtoForFilter
 */
export interface TaskDtoForFilter {
  /**
   *
   * @type {number}
   * @memberof TaskDtoForFilter
   */
  'page': number
  /**
   *
   * @type {number}
   * @memberof TaskDtoForFilter
   */
  'pageSize': number
  /**
   *
   * @type {string}
   * @memberof TaskDtoForFilter
   */
  'name'?: string
  /**
   *
   * @type {number}
   * @memberof TaskDtoForFilter
   */
  'courseId'?: number
  /**
   *
   * @type {string}
   * @memberof TaskDtoForFilter
   */
  'level'?: TaskDtoForFilterLevelEnum
  /**
   *
   * @type {string}
   * @memberof TaskDtoForFilter
   */
  'status'?: TaskDtoForFilterStatusEnum
}

export const TaskDtoForFilterLevelEnum = {
  Easy: 'EASY',
  Middle: 'MIDDLE',
  Hard: 'HARD',
} as const

export type TaskDtoForFilterLevelEnum =
  (typeof TaskDtoForFilterLevelEnum)[keyof typeof TaskDtoForFilterLevelEnum]
export const TaskDtoForFilterStatusEnum = {
  Active: 'ACTIVE',
  NotActive: 'NOT_ACTIVE',
  BeingEdited: 'BEING_EDITED',
} as const

export type TaskDtoForFilterStatusEnum =
  (typeof TaskDtoForFilterStatusEnum)[keyof typeof TaskDtoForFilterStatusEnum]

/**
 * TaskDto for the page where all tasks are displayed
 * @export
 * @interface TaskDtoForView
 */
export interface TaskDtoForView {
  /**
   *
   * @type {number}
   * @memberof TaskDtoForView
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof TaskDtoForView
   */
  'name'?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof TaskDtoForView
   */
  'course'?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof TaskDtoForView
   */
  'level'?: TaskDtoForViewLevelEnum
  /**
   *
   * @type {string}
   * @memberof TaskDtoForView
   */
  'status'?: TaskDtoForViewStatusEnum
}

export const TaskDtoForViewLevelEnum = {
  Easy: 'EASY',
  Middle: 'MIDDLE',
  Hard: 'HARD',
} as const

export type TaskDtoForViewLevelEnum =
  (typeof TaskDtoForViewLevelEnum)[keyof typeof TaskDtoForViewLevelEnum]
export const TaskDtoForViewStatusEnum = {
  Active: 'ACTIVE',
  NotActive: 'NOT_ACTIVE',
  BeingEdited: 'BEING_EDITED',
} as const

export type TaskDtoForViewStatusEnum =
  (typeof TaskDtoForViewStatusEnum)[keyof typeof TaskDtoForViewStatusEnum]

/**
 * ApplicationForDataUserControllerApi - axios parameter creator
 * @export
 */
export const ApplicationForDataUserControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for getting manager by id for information card
     * @param {number} id ID by which the manager is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdApplicationForEdit: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdApplicationForEdit', 'id', id)
      const localVarPath = `/api/v1/application-for-edit/getById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} page
     * @param {number} count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdApplicationForEdit1: async (
      page: number,
      count: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists('getByIdApplicationForEdit1', 'page', page)
      // verify required parameter 'count' is not null or undefined
      assertParamExists('getByIdApplicationForEdit1', 'count', count)
      const localVarPath = `/api/v1/application-for-edit/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (count !== undefined) {
        localVarQueryParameter['count'] = count
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {ApplicationStatusDto} applicationStatusDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendStatus: async (
      applicationStatusDto: ApplicationStatusDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationStatusDto' is not null or undefined
      assertParamExists(
        'sendStatus',
        'applicationStatusDto',
        applicationStatusDto
      )
      const localVarPath = `/api/v1/application-for-edit/sendStatus`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationStatusDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApplicationForDataUserControllerApi - functional programming interface
 * @export
 */
export const ApplicationForDataUserControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    ApplicationForDataUserControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for getting manager by id for information card
     * @param {number} id ID by which the manager is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdApplicationForEdit(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApplicationChangeDataUser>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getByIdApplicationForEdit(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'ApplicationForDataUserControllerApi.getByIdApplicationForEdit'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {number} page
     * @param {number} count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdApplicationForEdit1(
      page: number,
      count: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageApplicationChangeDataUser>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getByIdApplicationForEdit1(
          page,
          count,
          options
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'ApplicationForDataUserControllerApi.getByIdApplicationForEdit1'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {ApplicationStatusDto} applicationStatusDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendStatus(
      applicationStatusDto: ApplicationStatusDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendStatus(
        applicationStatusDto,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ApplicationForDataUserControllerApi.sendStatus']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ApplicationForDataUserControllerApi - factory interface
 * @export
 */
export const ApplicationForDataUserControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ApplicationForDataUserControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for getting manager by id for information card
     * @param {ApplicationForDataUserControllerApiGetByIdApplicationForEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdApplicationForEdit(
      requestParameters: ApplicationForDataUserControllerApiGetByIdApplicationForEditRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ApplicationChangeDataUser> {
      return localVarFp
        .getByIdApplicationForEdit(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {ApplicationForDataUserControllerApiGetByIdApplicationForEdit1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdApplicationForEdit1(
      requestParameters: ApplicationForDataUserControllerApiGetByIdApplicationForEdit1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageApplicationChangeDataUser> {
      return localVarFp
        .getByIdApplicationForEdit1(
          requestParameters.page,
          requestParameters.count,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {ApplicationForDataUserControllerApiSendStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendStatus(
      requestParameters: ApplicationForDataUserControllerApiSendStatusRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .sendStatus(requestParameters.applicationStatusDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for getByIdApplicationForEdit operation in ApplicationForDataUserControllerApi.
 * @export
 * @interface ApplicationForDataUserControllerApiGetByIdApplicationForEditRequest
 */
export interface ApplicationForDataUserControllerApiGetByIdApplicationForEditRequest {
  /**
   * ID by which the manager is being searched
   * @type {number}
   * @memberof ApplicationForDataUserControllerApiGetByIdApplicationForEdit
   */
  readonly id: number
}

/**
 * Request parameters for getByIdApplicationForEdit1 operation in ApplicationForDataUserControllerApi.
 * @export
 * @interface ApplicationForDataUserControllerApiGetByIdApplicationForEdit1Request
 */
export interface ApplicationForDataUserControllerApiGetByIdApplicationForEdit1Request {
  /**
   *
   * @type {number}
   * @memberof ApplicationForDataUserControllerApiGetByIdApplicationForEdit1
   */
  readonly page: number

  /**
   *
   * @type {number}
   * @memberof ApplicationForDataUserControllerApiGetByIdApplicationForEdit1
   */
  readonly count: number
}

/**
 * Request parameters for sendStatus operation in ApplicationForDataUserControllerApi.
 * @export
 * @interface ApplicationForDataUserControllerApiSendStatusRequest
 */
export interface ApplicationForDataUserControllerApiSendStatusRequest {
  /**
   *
   * @type {ApplicationStatusDto}
   * @memberof ApplicationForDataUserControllerApiSendStatus
   */
  readonly applicationStatusDto: ApplicationStatusDto
}

/**
 * ApplicationForDataUserControllerApi - object-oriented interface
 * @export
 * @class ApplicationForDataUserControllerApi
 * @extends {BaseAPI}
 */
export class ApplicationForDataUserControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for getting manager by id for information card
   * @param {ApplicationForDataUserControllerApiGetByIdApplicationForEditRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationForDataUserControllerApi
   */
  public getByIdApplicationForEdit(
    requestParameters: ApplicationForDataUserControllerApiGetByIdApplicationForEditRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ApplicationForDataUserControllerApiFp(this.configuration)
      .getByIdApplicationForEdit(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {ApplicationForDataUserControllerApiGetByIdApplicationForEdit1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationForDataUserControllerApi
   */
  public getByIdApplicationForEdit1(
    requestParameters: ApplicationForDataUserControllerApiGetByIdApplicationForEdit1Request,
    options?: RawAxiosRequestConfig
  ) {
    return ApplicationForDataUserControllerApiFp(this.configuration)
      .getByIdApplicationForEdit1(
        requestParameters.page,
        requestParameters.count,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {ApplicationForDataUserControllerApiSendStatusRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationForDataUserControllerApi
   */
  public sendStatus(
    requestParameters: ApplicationForDataUserControllerApiSendStatusRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ApplicationForDataUserControllerApiFp(this.configuration)
      .sendStatus(requestParameters.applicationStatusDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Authorization user
     * @param {JwtRequest} jwtRequest Data for authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      jwtRequest: JwtRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jwtRequest' is not null or undefined
      assertParamExists('login', 'jwtRequest', jwtRequest)
      const localVarPath = `/api/v1/auth/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        jwtRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update the access token
     * @param {string} refreshToken Refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh: async (
      refreshToken: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshToken' is not null or undefined
      assertParamExists('refresh', 'refreshToken', refreshToken)
      const localVarPath = `/api/v1/auth/refresh`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (refreshToken != null) {
        localVarHeaderParameter['refreshToken'] = String(refreshToken)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Authorization user
     * @param {JwtRequest} jwtRequest Data for authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      jwtRequest: JwtRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        jwtRequest,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthControllerApi.login']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Update the access token
     * @param {string} refreshToken Refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refresh(
      refreshToken: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(
        refreshToken,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthControllerApi.refresh']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthControllerApiFp(configuration)
  return {
    /**
     *
     * @summary Authorization user
     * @param {AuthControllerApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      requestParameters: AuthControllerApiLoginRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<JwtResponse> {
      return localVarFp
        .login(requestParameters.jwtRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update the access token
     * @param {AuthControllerApiRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh(
      requestParameters: AuthControllerApiRefreshRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<JwtResponse> {
      return localVarFp
        .refresh(requestParameters.refreshToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for login operation in AuthControllerApi.
 * @export
 * @interface AuthControllerApiLoginRequest
 */
export interface AuthControllerApiLoginRequest {
  /**
   * Data for authorization
   * @type {JwtRequest}
   * @memberof AuthControllerApiLogin
   */
  readonly jwtRequest: JwtRequest
}

/**
 * Request parameters for refresh operation in AuthControllerApi.
 * @export
 * @interface AuthControllerApiRefreshRequest
 */
export interface AuthControllerApiRefreshRequest {
  /**
   * Refresh token
   * @type {string}
   * @memberof AuthControllerApiRefresh
   */
  readonly refreshToken: string
}

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
  /**
   *
   * @summary Authorization user
   * @param {AuthControllerApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public login(
    requestParameters: AuthControllerApiLoginRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthControllerApiFp(this.configuration)
      .login(requestParameters.jwtRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update the access token
   * @param {AuthControllerApiRefreshRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public refresh(
    requestParameters: AuthControllerApiRefreshRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthControllerApiFp(this.configuration)
      .refresh(requestParameters.refreshToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContactControllerApi - axios parameter creator
 * @export
 */
export const ContactControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for add contacts.
     * @param {ContactDto} contactDto Dto for adding contacts\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add7: async (
      contactDto: ContactDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contactDto' is not null or undefined
      assertParamExists('add7', 'contactDto', contactDto)
      const localVarPath = `/api/v1/contact/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        contactDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for changing contacts\'s display by id.
     * @param {number} id ID by which the contacts is being updated
     * @param {boolean} display Contact\&#39;s display will change to this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayById: async (
      id: number,
      display: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('changeDisplayById', 'id', id)
      // verify required parameter 'display' is not null or undefined
      assertParamExists('changeDisplayById', 'display', display)
      const localVarPath = `/api/v1/contact/changeDisplayById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (display !== undefined) {
        localVarQueryParameter['display'] = display
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for update contacts.
     * @param {number} id id by which the object will be updated
     * @param {ContactDto} contactDto Dto for updating contacts\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit6: async (
      id: number,
      contactDto: ContactDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('edit6', 'id', id)
      // verify required parameter 'contactDto' is not null or undefined
      assertParamExists('edit6', 'contactDto', contactDto)
      const localVarPath = `/api/v1/contact/edit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        contactDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all contacts.
     * @param {ContactDtoForFilter} contactDtoForFilter Dto for filtering data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll7: async (
      contactDtoForFilter: ContactDtoForFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contactDtoForFilter' is not null or undefined
      assertParamExists('getAll7', 'contactDtoForFilter', contactDtoForFilter)
      const localVarPath = `/api/v1/contact/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (contactDtoForFilter !== undefined) {
        for (const [key, value] of Object.entries(contactDtoForFilter)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting contacts by id.
     * @param {number} id ID by which the contacts is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById3: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getById3', 'id', id)
      const localVarPath = `/api/v1/contact/getById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContactControllerApi - functional programming interface
 * @export
 */
export const ContactControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ContactControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for add contacts.
     * @param {ContactDto} contactDto Dto for adding contacts\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add7(
      contactDto: ContactDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add7(
        contactDto,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContactControllerApi.add7']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for changing contacts\'s display by id.
     * @param {number} id ID by which the contacts is being updated
     * @param {boolean} display Contact\&#39;s display will change to this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeDisplayById(
      id: number,
      display: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.changeDisplayById(id, display, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContactControllerApi.changeDisplayById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for update contacts.
     * @param {number} id id by which the object will be updated
     * @param {ContactDto} contactDto Dto for updating contacts\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async edit6(
      id: number,
      contactDto: ContactDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.edit6(
        id,
        contactDto,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContactControllerApi.edit6']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all contacts.
     * @param {ContactDtoForFilter} contactDtoForFilter Dto for filtering data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll7(
      contactDtoForFilter: ContactDtoForFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageContactDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll7(
        contactDtoForFilter,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContactControllerApi.getAll7']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting contacts by id.
     * @param {number} id ID by which the contacts is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getById3(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getById3(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ContactControllerApi.getById3']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ContactControllerApi - factory interface
 * @export
 */
export const ContactControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ContactControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for add contacts.
     * @param {ContactControllerApiAdd7Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add7(
      requestParameters: ContactControllerApiAdd7Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .add7(requestParameters.contactDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for changing contacts\'s display by id.
     * @param {ContactControllerApiChangeDisplayByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeDisplayById(
      requestParameters: ContactControllerApiChangeDisplayByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .changeDisplayById(
          requestParameters.id,
          requestParameters.display,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for update contacts.
     * @param {ContactControllerApiEdit6Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit6(
      requestParameters: ContactControllerApiEdit6Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .edit6(requestParameters.id, requestParameters.contactDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all contacts.
     * @param {ContactControllerApiGetAll7Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll7(
      requestParameters: ContactControllerApiGetAll7Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageContactDto> {
      return localVarFp
        .getAll7(requestParameters.contactDtoForFilter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting contacts by id.
     * @param {ContactControllerApiGetById3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById3(
      requestParameters: ContactControllerApiGetById3Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ContactDto> {
      return localVarFp
        .getById3(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for add7 operation in ContactControllerApi.
 * @export
 * @interface ContactControllerApiAdd7Request
 */
export interface ContactControllerApiAdd7Request {
  /**
   * Dto for adding contacts\&#39;s data.
   * @type {ContactDto}
   * @memberof ContactControllerApiAdd7
   */
  readonly contactDto: ContactDto
}

/**
 * Request parameters for changeDisplayById operation in ContactControllerApi.
 * @export
 * @interface ContactControllerApiChangeDisplayByIdRequest
 */
export interface ContactControllerApiChangeDisplayByIdRequest {
  /**
   * ID by which the contacts is being updated
   * @type {number}
   * @memberof ContactControllerApiChangeDisplayById
   */
  readonly id: number

  /**
   * Contact\&#39;s display will change to this value
   * @type {boolean}
   * @memberof ContactControllerApiChangeDisplayById
   */
  readonly display: boolean
}

/**
 * Request parameters for edit6 operation in ContactControllerApi.
 * @export
 * @interface ContactControllerApiEdit6Request
 */
export interface ContactControllerApiEdit6Request {
  /**
   * id by which the object will be updated
   * @type {number}
   * @memberof ContactControllerApiEdit6
   */
  readonly id: number

  /**
   * Dto for updating contacts\&#39;s data.
   * @type {ContactDto}
   * @memberof ContactControllerApiEdit6
   */
  readonly contactDto: ContactDto
}

/**
 * Request parameters for getAll7 operation in ContactControllerApi.
 * @export
 * @interface ContactControllerApiGetAll7Request
 */
export interface ContactControllerApiGetAll7Request {
  /**
   * Dto for filtering data.
   * @type {ContactDtoForFilter}
   * @memberof ContactControllerApiGetAll7
   */
  readonly contactDtoForFilter: ContactDtoForFilter
}

/**
 * Request parameters for getById3 operation in ContactControllerApi.
 * @export
 * @interface ContactControllerApiGetById3Request
 */
export interface ContactControllerApiGetById3Request {
  /**
   * ID by which the contacts is being searched
   * @type {number}
   * @memberof ContactControllerApiGetById3
   */
  readonly id: number
}

/**
 * ContactControllerApi - object-oriented interface
 * @export
 * @class ContactControllerApi
 * @extends {BaseAPI}
 */
export class ContactControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for add contacts.
   * @param {ContactControllerApiAdd7Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactControllerApi
   */
  public add7(
    requestParameters: ContactControllerApiAdd7Request,
    options?: RawAxiosRequestConfig
  ) {
    return ContactControllerApiFp(this.configuration)
      .add7(requestParameters.contactDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for changing contacts\'s display by id.
   * @param {ContactControllerApiChangeDisplayByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactControllerApi
   */
  public changeDisplayById(
    requestParameters: ContactControllerApiChangeDisplayByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ContactControllerApiFp(this.configuration)
      .changeDisplayById(
        requestParameters.id,
        requestParameters.display,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for update contacts.
   * @param {ContactControllerApiEdit6Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactControllerApi
   */
  public edit6(
    requestParameters: ContactControllerApiEdit6Request,
    options?: RawAxiosRequestConfig
  ) {
    return ContactControllerApiFp(this.configuration)
      .edit6(requestParameters.id, requestParameters.contactDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all contacts.
   * @param {ContactControllerApiGetAll7Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactControllerApi
   */
  public getAll7(
    requestParameters: ContactControllerApiGetAll7Request,
    options?: RawAxiosRequestConfig
  ) {
    return ContactControllerApiFp(this.configuration)
      .getAll7(requestParameters.contactDtoForFilter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting contacts by id.
   * @param {ContactControllerApiGetById3Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactControllerApi
   */
  public getById3(
    requestParameters: ContactControllerApiGetById3Request,
    options?: RawAxiosRequestConfig
  ) {
    return ContactControllerApiFp(this.configuration)
      .getById3(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CourseControllerApi - axios parameter creator
 * @export
 */
export const CourseControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for add some courses.
     * @param {CourseDtoForAdd} courseDtoForAdd Dto for add courses\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add6: async (
      courseDtoForAdd: CourseDtoForAdd,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'courseDtoForAdd' is not null or undefined
      assertParamExists('add6', 'courseDtoForAdd', courseDtoForAdd)
      const localVarPath = `/api/v1/course/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        courseDtoForAdd,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for delete manager
     * @param {number} id ID by which the courses is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById6: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteById6', 'id', id)
      const localVarPath = `/api/v1/course/deleteById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for update some courses.
     * @param {number} id id by which the object will be updated
     * @param {CourseDtoForAdd} courseDtoForAdd Dto for edit courses\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit5: async (
      id: number,
      courseDtoForAdd: CourseDtoForAdd,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('edit5', 'id', id)
      // verify required parameter 'courseDtoForAdd' is not null or undefined
      assertParamExists('edit5', 'courseDtoForAdd', courseDtoForAdd)
      const localVarPath = `/api/v1/course/edit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        courseDtoForAdd,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all courses.
     * @param {CourseDtoFotFilter} courseDtoFotFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll6: async (
      courseDtoFotFilter: CourseDtoFotFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'courseDtoFotFilter' is not null or undefined
      assertParamExists('getAll6', 'courseDtoFotFilter', courseDtoFotFilter)
      const localVarPath = `/api/v1/course/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (courseDtoFotFilter !== undefined) {
        for (const [key, value] of Object.entries(courseDtoFotFilter)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting courses by id for edit page
     * @param {number} id ID by which the courses is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForEdit3: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdForEdit3', 'id', id)
      const localVarPath = `/api/v1/course/getByIdForEdit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting courses by id for information card
     * @param {number} id ID by which the courses is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForView3: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdForView3', 'id', id)
      const localVarPath = `/api/v1/course/getByIdForView`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CourseControllerApi - functional programming interface
 * @export
 */
export const CourseControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CourseControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for add some courses.
     * @param {CourseDtoForAdd} courseDtoForAdd Dto for add courses\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add6(
      courseDtoForAdd: CourseDtoForAdd,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add6(
        courseDtoForAdd,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CourseControllerApi.add6']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for delete manager
     * @param {number} id ID by which the courses is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteById6(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById6(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CourseControllerApi.deleteById6']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for update some courses.
     * @param {number} id id by which the object will be updated
     * @param {CourseDtoForAdd} courseDtoForAdd Dto for edit courses\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async edit5(
      id: number,
      courseDtoForAdd: CourseDtoForAdd,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.edit5(
        id,
        courseDtoForAdd,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CourseControllerApi.edit5']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all courses.
     * @param {CourseDtoFotFilter} courseDtoFotFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll6(
      courseDtoFotFilter: CourseDtoFotFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageCourseDtoForViewAndCard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll6(
        courseDtoFotFilter,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CourseControllerApi.getAll6']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting courses by id for edit page
     * @param {number} id ID by which the courses is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdForEdit3(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseDtoForEdit>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdForEdit3(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CourseControllerApi.getByIdForEdit3']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting courses by id for information card
     * @param {number} id ID by which the courses is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdForView3(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CourseDtoForViewAndCard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdForView3(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CourseControllerApi.getByIdForView3']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * CourseControllerApi - factory interface
 * @export
 */
export const CourseControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CourseControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for add some courses.
     * @param {CourseControllerApiAdd6Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add6(
      requestParameters: CourseControllerApiAdd6Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .add6(requestParameters.courseDtoForAdd, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for delete manager
     * @param {CourseControllerApiDeleteById6Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById6(
      requestParameters: CourseControllerApiDeleteById6Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .deleteById6(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for update some courses.
     * @param {CourseControllerApiEdit5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit5(
      requestParameters: CourseControllerApiEdit5Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .edit5(requestParameters.id, requestParameters.courseDtoForAdd, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all courses.
     * @param {CourseControllerApiGetAll6Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll6(
      requestParameters: CourseControllerApiGetAll6Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageCourseDtoForViewAndCard> {
      return localVarFp
        .getAll6(requestParameters.courseDtoFotFilter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting courses by id for edit page
     * @param {CourseControllerApiGetByIdForEdit3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForEdit3(
      requestParameters: CourseControllerApiGetByIdForEdit3Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CourseDtoForEdit> {
      return localVarFp
        .getByIdForEdit3(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting courses by id for information card
     * @param {CourseControllerApiGetByIdForView3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForView3(
      requestParameters: CourseControllerApiGetByIdForView3Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CourseDtoForViewAndCard> {
      return localVarFp
        .getByIdForView3(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for add6 operation in CourseControllerApi.
 * @export
 * @interface CourseControllerApiAdd6Request
 */
export interface CourseControllerApiAdd6Request {
  /**
   * Dto for add courses\&#39;s data.
   * @type {CourseDtoForAdd}
   * @memberof CourseControllerApiAdd6
   */
  readonly courseDtoForAdd: CourseDtoForAdd
}

/**
 * Request parameters for deleteById6 operation in CourseControllerApi.
 * @export
 * @interface CourseControllerApiDeleteById6Request
 */
export interface CourseControllerApiDeleteById6Request {
  /**
   * ID by which the courses is being deleted
   * @type {number}
   * @memberof CourseControllerApiDeleteById6
   */
  readonly id: number
}

/**
 * Request parameters for edit5 operation in CourseControllerApi.
 * @export
 * @interface CourseControllerApiEdit5Request
 */
export interface CourseControllerApiEdit5Request {
  /**
   * id by which the object will be updated
   * @type {number}
   * @memberof CourseControllerApiEdit5
   */
  readonly id: number

  /**
   * Dto for edit courses\&#39;s data.
   * @type {CourseDtoForAdd}
   * @memberof CourseControllerApiEdit5
   */
  readonly courseDtoForAdd: CourseDtoForAdd
}

/**
 * Request parameters for getAll6 operation in CourseControllerApi.
 * @export
 * @interface CourseControllerApiGetAll6Request
 */
export interface CourseControllerApiGetAll6Request {
  /**
   * DTO for filter date. This DTO also has date for pagination
   * @type {CourseDtoFotFilter}
   * @memberof CourseControllerApiGetAll6
   */
  readonly courseDtoFotFilter: CourseDtoFotFilter
}

/**
 * Request parameters for getByIdForEdit3 operation in CourseControllerApi.
 * @export
 * @interface CourseControllerApiGetByIdForEdit3Request
 */
export interface CourseControllerApiGetByIdForEdit3Request {
  /**
   * ID by which the courses is being searched
   * @type {number}
   * @memberof CourseControllerApiGetByIdForEdit3
   */
  readonly id: number
}

/**
 * Request parameters for getByIdForView3 operation in CourseControllerApi.
 * @export
 * @interface CourseControllerApiGetByIdForView3Request
 */
export interface CourseControllerApiGetByIdForView3Request {
  /**
   * ID by which the courses is being searched
   * @type {number}
   * @memberof CourseControllerApiGetByIdForView3
   */
  readonly id: number
}

/**
 * CourseControllerApi - object-oriented interface
 * @export
 * @class CourseControllerApi
 * @extends {BaseAPI}
 */
export class CourseControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for add some courses.
   * @param {CourseControllerApiAdd6Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CourseControllerApi
   */
  public add6(
    requestParameters: CourseControllerApiAdd6Request,
    options?: RawAxiosRequestConfig
  ) {
    return CourseControllerApiFp(this.configuration)
      .add6(requestParameters.courseDtoForAdd, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for delete manager
   * @param {CourseControllerApiDeleteById6Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CourseControllerApi
   */
  public deleteById6(
    requestParameters: CourseControllerApiDeleteById6Request,
    options?: RawAxiosRequestConfig
  ) {
    return CourseControllerApiFp(this.configuration)
      .deleteById6(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for update some courses.
   * @param {CourseControllerApiEdit5Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CourseControllerApi
   */
  public edit5(
    requestParameters: CourseControllerApiEdit5Request,
    options?: RawAxiosRequestConfig
  ) {
    return CourseControllerApiFp(this.configuration)
      .edit5(requestParameters.id, requestParameters.courseDtoForAdd, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all courses.
   * @param {CourseControllerApiGetAll6Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CourseControllerApi
   */
  public getAll6(
    requestParameters: CourseControllerApiGetAll6Request,
    options?: RawAxiosRequestConfig
  ) {
    return CourseControllerApiFp(this.configuration)
      .getAll6(requestParameters.courseDtoFotFilter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting courses by id for edit page
   * @param {CourseControllerApiGetByIdForEdit3Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CourseControllerApi
   */
  public getByIdForEdit3(
    requestParameters: CourseControllerApiGetByIdForEdit3Request,
    options?: RawAxiosRequestConfig
  ) {
    return CourseControllerApiFp(this.configuration)
      .getByIdForEdit3(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting courses by id for information card
   * @param {CourseControllerApiGetByIdForView3Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CourseControllerApi
   */
  public getByIdForView3(
    requestParameters: CourseControllerApiGetByIdForView3Request,
    options?: RawAxiosRequestConfig
  ) {
    return CourseControllerApiFp(this.configuration)
      .getByIdForView3(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EnumControllerApi - axios parameter creator
 * @export
 */
export const EnumControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get all courses statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCourseStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/courseStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all current situations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCurrentSituations: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/currentSituations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all English levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEnglishLevels: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/englishLevels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all lesson statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLessonStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/lessonStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all task levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLevels: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/taskLevels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all literature types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLiteratureTypes: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/literatureTypes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all manager statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listManagerStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/managerStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPages: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/pages`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all preparation levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPreparationLevels: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/preparationLevels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStudentStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/studentStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all task for student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskForStudentStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/taskForStudentStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all task statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/taskStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EnumControllerApi - functional programming interface
 * @export
 */
export const EnumControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EnumControllerApiAxiosParamCreator(configuration)
  return {
    /**
     * Get all courses statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCourseStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listCourseStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listCourseStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all current situations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCurrentSituations(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listCurrentSituations(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listCurrentSituations']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all English levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEnglishLevels(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listEnglishLevels(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listEnglishLevels']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all lesson statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLessonStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listLessonStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listLessonStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all task levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLevels(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listLevels(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listLevels']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all literature types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLiteratureTypes(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listLiteratureTypes(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listLiteratureTypes']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all manager statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listManagerStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listManagerStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listManagerStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPages(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPages(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listPages']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all preparation levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPreparationLevels(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listPreparationLevels(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listPreparationLevels']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listStudentStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listStudentStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listStudentStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all task for student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTaskForStudentStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTaskForStudentStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listTaskForStudentStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all task statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTaskStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTaskStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listTaskStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * EnumControllerApi - factory interface
 * @export
 */
export const EnumControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EnumControllerApiFp(configuration)
  return {
    /**
     * Get all courses statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCourseStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listCourseStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all current situations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCurrentSituations(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listCurrentSituations(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all English levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEnglishLevels(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listEnglishLevels(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all lesson statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLessonStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listLessonStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all task levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLevels(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
      return localVarFp
        .listLevels(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all literature types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLiteratureTypes(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listLiteratureTypes(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all manager statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listManagerStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listManagerStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPages(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
      return localVarFp
        .listPages(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all preparation levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPreparationLevels(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listPreparationLevels(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStudentStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listStudentStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all task for student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskForStudentStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listTaskForStudentStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all task statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listTaskStatuses(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EnumControllerApi - object-oriented interface
 * @export
 * @class EnumControllerApi
 * @extends {BaseAPI}
 */
export class EnumControllerApi extends BaseAPI {
  /**
   * Get all courses statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listCourseStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listCourseStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all current situations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listCurrentSituations(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listCurrentSituations(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all English levels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listEnglishLevels(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listEnglishLevels(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all lesson statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listLessonStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listLessonStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all task levels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listLevels(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listLevels(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all literature types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listLiteratureTypes(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listLiteratureTypes(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all manager statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listManagerStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listManagerStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all pages
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listPages(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listPages(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all preparation levels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listPreparationLevels(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listPreparationLevels(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all student statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listStudentStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listStudentStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all task for student statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listTaskForStudentStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listTaskForStudentStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all task statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listTaskStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listTaskStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * LessonControllerApi - axios parameter creator
 * @export
 */
export const LessonControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for add lesson.
     * @param {string} link
     * @param {number} [courseId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add5: async (
      link: string,
      courseId?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'link' is not null or undefined
      assertParamExists('add5', 'link', link)
      const localVarPath = `/api/v1/lesson/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (courseId !== undefined) {
        localVarFormParams.append('courseId', courseId as any)
      }

      if (link !== undefined) {
        localVarFormParams.append('link', link as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request delete lesson, you can delete only lesson with status active.
     * @param {number} id ID by which the lesson is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById5: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteById5', 'id', id)
      const localVarPath = `/api/v1/lesson/deleteById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for end lesson.
     * @param {LessonDtoEnd} lessonDtoEnd The result of the lesson
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editLesson: async (
      lessonDtoEnd: LessonDtoEnd,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lessonDtoEnd' is not null or undefined
      assertParamExists('editLesson', 'lessonDtoEnd', lessonDtoEnd)
      const localVarPath = `/api/v1/lesson/edit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        lessonDtoEnd,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for end lesson.
     * @param {LessonDtoEnd} lessonDtoEnd The result of the lesson
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    endLesson: async (
      lessonDtoEnd: LessonDtoEnd,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lessonDtoEnd' is not null or undefined
      assertParamExists('endLesson', 'lessonDtoEnd', lessonDtoEnd)
      const localVarPath = `/api/v1/lesson/endLesson`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        lessonDtoEnd,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all lesson.
     * @param {LessonDtoForFilter} lessonDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll5: async (
      lessonDtoForFilter: LessonDtoForFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lessonDtoForFilter' is not null or undefined
      assertParamExists('getAll5', 'lessonDtoForFilter', lessonDtoForFilter)
      const localVarPath = `/api/v1/lesson/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (lessonDtoForFilter !== undefined) {
        for (const [key, value] of Object.entries(lessonDtoForFilter)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for get lesson by id.
     * @param {number} id ID by which the lesson is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById2: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getById2', 'id', id)
      const localVarPath = `/api/v1/lesson/getById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LessonControllerApi - functional programming interface
 * @export
 */
export const LessonControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    LessonControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for add lesson.
     * @param {string} link
     * @param {number} [courseId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add5(
      link: string,
      courseId?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add5(
        link,
        courseId,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LessonControllerApi.add5']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request delete lesson, you can delete only lesson with status active.
     * @param {number} id ID by which the lesson is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteById5(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById5(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LessonControllerApi.deleteById5']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for end lesson.
     * @param {LessonDtoEnd} lessonDtoEnd The result of the lesson
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editLesson(
      lessonDtoEnd: LessonDtoEnd,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editLesson(
        lessonDtoEnd,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LessonControllerApi.editLesson']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for end lesson.
     * @param {LessonDtoEnd} lessonDtoEnd The result of the lesson
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async endLesson(
      lessonDtoEnd: LessonDtoEnd,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.endLesson(
        lessonDtoEnd,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LessonControllerApi.endLesson']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all lesson.
     * @param {LessonDtoForFilter} lessonDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll5(
      lessonDtoForFilter: LessonDtoForFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll5(
        lessonDtoForFilter,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LessonControllerApi.getAll5']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for get lesson by id.
     * @param {number} id ID by which the lesson is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getById2(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lesson>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getById2(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LessonControllerApi.getById2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * LessonControllerApi - factory interface
 * @export
 */
export const LessonControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LessonControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for add lesson.
     * @param {LessonControllerApiAdd5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add5(
      requestParameters: LessonControllerApiAdd5Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .add5(requestParameters.link, requestParameters.courseId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request delete lesson, you can delete only lesson with status active.
     * @param {LessonControllerApiDeleteById5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById5(
      requestParameters: LessonControllerApiDeleteById5Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .deleteById5(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for end lesson.
     * @param {LessonControllerApiEditLessonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editLesson(
      requestParameters: LessonControllerApiEditLessonRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .editLesson(requestParameters.lessonDtoEnd, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for end lesson.
     * @param {LessonControllerApiEndLessonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    endLesson(
      requestParameters: LessonControllerApiEndLessonRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .endLesson(requestParameters.lessonDtoEnd, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all lesson.
     * @param {LessonControllerApiGetAll5Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll5(
      requestParameters: LessonControllerApiGetAll5Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .getAll5(requestParameters.lessonDtoForFilter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for get lesson by id.
     * @param {LessonControllerApiGetById2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById2(
      requestParameters: LessonControllerApiGetById2Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Lesson> {
      return localVarFp
        .getById2(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for add5 operation in LessonControllerApi.
 * @export
 * @interface LessonControllerApiAdd5Request
 */
export interface LessonControllerApiAdd5Request {
  /**
   *
   * @type {string}
   * @memberof LessonControllerApiAdd5
   */
  readonly link: string

  /**
   *
   * @type {number}
   * @memberof LessonControllerApiAdd5
   */
  readonly courseId?: number
}

/**
 * Request parameters for deleteById5 operation in LessonControllerApi.
 * @export
 * @interface LessonControllerApiDeleteById5Request
 */
export interface LessonControllerApiDeleteById5Request {
  /**
   * ID by which the lesson is being deleted
   * @type {number}
   * @memberof LessonControllerApiDeleteById5
   */
  readonly id: number
}

/**
 * Request parameters for editLesson operation in LessonControllerApi.
 * @export
 * @interface LessonControllerApiEditLessonRequest
 */
export interface LessonControllerApiEditLessonRequest {
  /**
   * The result of the lesson
   * @type {LessonDtoEnd}
   * @memberof LessonControllerApiEditLesson
   */
  readonly lessonDtoEnd: LessonDtoEnd
}

/**
 * Request parameters for endLesson operation in LessonControllerApi.
 * @export
 * @interface LessonControllerApiEndLessonRequest
 */
export interface LessonControllerApiEndLessonRequest {
  /**
   * The result of the lesson
   * @type {LessonDtoEnd}
   * @memberof LessonControllerApiEndLesson
   */
  readonly lessonDtoEnd: LessonDtoEnd
}

/**
 * Request parameters for getAll5 operation in LessonControllerApi.
 * @export
 * @interface LessonControllerApiGetAll5Request
 */
export interface LessonControllerApiGetAll5Request {
  /**
   * DTO for filter date. This DTO also has date for pagination
   * @type {LessonDtoForFilter}
   * @memberof LessonControllerApiGetAll5
   */
  readonly lessonDtoForFilter: LessonDtoForFilter
}

/**
 * Request parameters for getById2 operation in LessonControllerApi.
 * @export
 * @interface LessonControllerApiGetById2Request
 */
export interface LessonControllerApiGetById2Request {
  /**
   * ID by which the lesson is being searched
   * @type {number}
   * @memberof LessonControllerApiGetById2
   */
  readonly id: number
}

/**
 * LessonControllerApi - object-oriented interface
 * @export
 * @class LessonControllerApi
 * @extends {BaseAPI}
 */
export class LessonControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for add lesson.
   * @param {LessonControllerApiAdd5Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonControllerApi
   */
  public add5(
    requestParameters: LessonControllerApiAdd5Request,
    options?: RawAxiosRequestConfig
  ) {
    return LessonControllerApiFp(this.configuration)
      .add5(requestParameters.link, requestParameters.courseId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request delete lesson, you can delete only lesson with status active.
   * @param {LessonControllerApiDeleteById5Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonControllerApi
   */
  public deleteById5(
    requestParameters: LessonControllerApiDeleteById5Request,
    options?: RawAxiosRequestConfig
  ) {
    return LessonControllerApiFp(this.configuration)
      .deleteById5(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for end lesson.
   * @param {LessonControllerApiEditLessonRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonControllerApi
   */
  public editLesson(
    requestParameters: LessonControllerApiEditLessonRequest,
    options?: RawAxiosRequestConfig
  ) {
    return LessonControllerApiFp(this.configuration)
      .editLesson(requestParameters.lessonDtoEnd, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for end lesson.
   * @param {LessonControllerApiEndLessonRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonControllerApi
   */
  public endLesson(
    requestParameters: LessonControllerApiEndLessonRequest,
    options?: RawAxiosRequestConfig
  ) {
    return LessonControllerApiFp(this.configuration)
      .endLesson(requestParameters.lessonDtoEnd, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all lesson.
   * @param {LessonControllerApiGetAll5Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonControllerApi
   */
  public getAll5(
    requestParameters: LessonControllerApiGetAll5Request,
    options?: RawAxiosRequestConfig
  ) {
    return LessonControllerApiFp(this.configuration)
      .getAll5(requestParameters.lessonDtoForFilter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for get lesson by id.
   * @param {LessonControllerApiGetById2Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonControllerApi
   */
  public getById2(
    requestParameters: LessonControllerApiGetById2Request,
    options?: RawAxiosRequestConfig
  ) {
    return LessonControllerApiFp(this.configuration)
      .getById2(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * LiteratureControllerApi - axios parameter creator
 * @export
 */
export const LiteratureControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for add literature.
     * @param {string} name
     * @param {string} linkForDownload
     * @param {Add4TypeLiteratureEnum} typeLiterature
     * @param {Array<string>} keyWords
     * @param {number} course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add4: async (
      name: string,
      linkForDownload: string,
      typeLiterature: Add4TypeLiteratureEnum,
      keyWords: Array<string>,
      course: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('add4', 'name', name)
      // verify required parameter 'linkForDownload' is not null or undefined
      assertParamExists('add4', 'linkForDownload', linkForDownload)
      // verify required parameter 'typeLiterature' is not null or undefined
      assertParamExists('add4', 'typeLiterature', typeLiterature)
      // verify required parameter 'keyWords' is not null or undefined
      assertParamExists('add4', 'keyWords', keyWords)
      // verify required parameter 'courses' is not null or undefined
      assertParamExists('add4', 'course', course)
      const localVarPath = `/api/v1/literature/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (linkForDownload !== undefined) {
        localVarFormParams.append('linkForDownload', linkForDownload as any)
      }

      if (typeLiterature !== undefined) {
        localVarFormParams.append('typeLiterature', typeLiterature as any)
      }
      if (keyWords) {
        localVarFormParams.append(
          'keyWords',
          keyWords.join(COLLECTION_FORMATS.csv)
        )
      }

      if (course !== undefined) {
        localVarFormParams.append('course', course as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for delete literature
     * @param {number} id ID by which the literature is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById4: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteById4', 'id', id)
      const localVarPath = `/api/v1/literature/deleteById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for edit literature.
     * @param {number} id ID by which the literature is being edited
     * @param {string} name
     * @param {string} linkForDownload
     * @param {Edit4TypeLiteratureEnum} typeLiterature
     * @param {Array<string>} keyWords
     * @param {number} course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit4: async (
      id: number,
      name: string,
      linkForDownload: string,
      typeLiterature: Edit4TypeLiteratureEnum,
      keyWords: Array<string>,
      course: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('edit4', 'id', id)
      // verify required parameter 'name' is not null or undefined
      assertParamExists('edit4', 'name', name)
      // verify required parameter 'linkForDownload' is not null or undefined
      assertParamExists('edit4', 'linkForDownload', linkForDownload)
      // verify required parameter 'typeLiterature' is not null or undefined
      assertParamExists('edit4', 'typeLiterature', typeLiterature)
      // verify required parameter 'keyWords' is not null or undefined
      assertParamExists('edit4', 'keyWords', keyWords)
      // verify required parameter 'courses' is not null or undefined
      assertParamExists('edit4', 'course', course)
      const localVarPath = `/api/v1/literature/edit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (linkForDownload !== undefined) {
        localVarFormParams.append('linkForDownload', linkForDownload as any)
      }

      if (typeLiterature !== undefined) {
        localVarFormParams.append('typeLiterature', typeLiterature as any)
      }
      if (keyWords) {
        localVarFormParams.append(
          'keyWords',
          keyWords.join(COLLECTION_FORMATS.csv)
        )
      }

      if (course !== undefined) {
        localVarFormParams.append('course', course as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all literature.
     * @param {LiteratureDtoForFilter} literatureDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll4: async (
      literatureDtoForFilter: LiteratureDtoForFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'literatureDtoForFilter' is not null or undefined
      assertParamExists(
        'getAll4',
        'literatureDtoForFilter',
        literatureDtoForFilter
      )
      const localVarPath = `/api/v1/literature/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (literatureDtoForFilter !== undefined) {
        for (const [key, value] of Object.entries(literatureDtoForFilter)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for get literature by id.
     * @param {number} id ID by which the literature is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById1: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getById1', 'id', id)
      const localVarPath = `/api/v1/literature/getById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LiteratureControllerApi - functional programming interface
 * @export
 */
export const LiteratureControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    LiteratureControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for add literature.
     * @param {string} name
     * @param {string} linkForDownload
     * @param {Add4TypeLiteratureEnum} typeLiterature
     * @param {Array<string>} keyWords
     * @param {number} course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add4(
      name: string,
      linkForDownload: string,
      typeLiterature: Add4TypeLiteratureEnum,
      keyWords: Array<string>,
      course: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add4(
        name,
        linkForDownload,
        typeLiterature,
        keyWords,
        course,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LiteratureControllerApi.add4']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for delete literature
     * @param {number} id ID by which the literature is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteById4(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById4(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LiteratureControllerApi.deleteById4']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for edit literature.
     * @param {number} id ID by which the literature is being edited
     * @param {string} name
     * @param {string} linkForDownload
     * @param {Edit4TypeLiteratureEnum} typeLiterature
     * @param {Array<string>} keyWords
     * @param {number} course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async edit4(
      id: number,
      name: string,
      linkForDownload: string,
      typeLiterature: Edit4TypeLiteratureEnum,
      keyWords: Array<string>,
      course: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.edit4(
        id,
        name,
        linkForDownload,
        typeLiterature,
        keyWords,
        course,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LiteratureControllerApi.edit4']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all literature.
     * @param {LiteratureDtoForFilter} literatureDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll4(
      literatureDtoForFilter: LiteratureDtoForFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageLiteratureDtoForView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll4(
        literatureDtoForFilter,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LiteratureControllerApi.getAll4']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for get literature by id.
     * @param {number} id ID by which the literature is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getById1(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Literature>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getById1(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LiteratureControllerApi.getById1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * LiteratureControllerApi - factory interface
 * @export
 */
export const LiteratureControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LiteratureControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for add literature.
     * @param {LiteratureControllerApiAdd4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add4(
      requestParameters: LiteratureControllerApiAdd4Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .add4(
          requestParameters.name,
          requestParameters.linkForDownload,
          requestParameters.typeLiterature,
          requestParameters.keyWords,
          requestParameters.course,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for delete literature
     * @param {LiteratureControllerApiDeleteById4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById4(
      requestParameters: LiteratureControllerApiDeleteById4Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .deleteById4(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for edit literature.
     * @param {LiteratureControllerApiEdit4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit4(
      requestParameters: LiteratureControllerApiEdit4Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .edit4(
          requestParameters.id,
          requestParameters.name,
          requestParameters.linkForDownload,
          requestParameters.typeLiterature,
          requestParameters.keyWords,
          requestParameters.course,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all literature.
     * @param {LiteratureControllerApiGetAll4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll4(
      requestParameters: LiteratureControllerApiGetAll4Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageLiteratureDtoForView> {
      return localVarFp
        .getAll4(requestParameters.literatureDtoForFilter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for get literature by id.
     * @param {LiteratureControllerApiGetById1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById1(
      requestParameters: LiteratureControllerApiGetById1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Literature> {
      return localVarFp
        .getById1(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for add4 operation in LiteratureControllerApi.
 * @export
 * @interface LiteratureControllerApiAdd4Request
 */
export interface LiteratureControllerApiAdd4Request {
  /**
   *
   * @type {string}
   * @memberof LiteratureControllerApiAdd4
   */
  readonly name: string

  /**
   *
   * @type {string}
   * @memberof LiteratureControllerApiAdd4
   */
  readonly linkForDownload: string

  /**
   *
   * @type {string}
   * @memberof LiteratureControllerApiAdd4
   */
  readonly typeLiterature: Add4TypeLiteratureEnum

  /**
   *
   * @type {Array<string>}
   * @memberof LiteratureControllerApiAdd4
   */
  readonly keyWords: Array<string>

  /**
   *
   * @type {number}
   * @memberof LiteratureControllerApiAdd4
   */
  readonly course: number
}

/**
 * Request parameters for deleteById4 operation in LiteratureControllerApi.
 * @export
 * @interface LiteratureControllerApiDeleteById4Request
 */
export interface LiteratureControllerApiDeleteById4Request {
  /**
   * ID by which the literature is being deleted
   * @type {number}
   * @memberof LiteratureControllerApiDeleteById4
   */
  readonly id: number
}

/**
 * Request parameters for edit4 operation in LiteratureControllerApi.
 * @export
 * @interface LiteratureControllerApiEdit4Request
 */
export interface LiteratureControllerApiEdit4Request {
  /**
   * ID by which the literature is being edited
   * @type {number}
   * @memberof LiteratureControllerApiEdit4
   */
  readonly id: number

  /**
   *
   * @type {string}
   * @memberof LiteratureControllerApiEdit4
   */
  readonly name: string

  /**
   *
   * @type {string}
   * @memberof LiteratureControllerApiEdit4
   */
  readonly linkForDownload: string

  /**
   *
   * @type {string}
   * @memberof LiteratureControllerApiEdit4
   */
  readonly typeLiterature: Edit4TypeLiteratureEnum

  /**
   *
   * @type {Array<string>}
   * @memberof LiteratureControllerApiEdit4
   */
  readonly keyWords: Array<string>

  /**
   *
   * @type {number}
   * @memberof LiteratureControllerApiEdit4
   */
  readonly course: number
}

/**
 * Request parameters for getAll4 operation in LiteratureControllerApi.
 * @export
 * @interface LiteratureControllerApiGetAll4Request
 */
export interface LiteratureControllerApiGetAll4Request {
  /**
   * DTO for filter date. This DTO also has date for pagination
   * @type {LiteratureDtoForFilter}
   * @memberof LiteratureControllerApiGetAll4
   */
  readonly literatureDtoForFilter: LiteratureDtoForFilter
}

/**
 * Request parameters for getById1 operation in LiteratureControllerApi.
 * @export
 * @interface LiteratureControllerApiGetById1Request
 */
export interface LiteratureControllerApiGetById1Request {
  /**
   * ID by which the literature is being searched
   * @type {number}
   * @memberof LiteratureControllerApiGetById1
   */
  readonly id: number
}

/**
 * LiteratureControllerApi - object-oriented interface
 * @export
 * @class LiteratureControllerApi
 * @extends {BaseAPI}
 */
export class LiteratureControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for add literature.
   * @param {LiteratureControllerApiAdd4Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteratureControllerApi
   */
  public add4(
    requestParameters: LiteratureControllerApiAdd4Request,
    options?: RawAxiosRequestConfig
  ) {
    return LiteratureControllerApiFp(this.configuration)
      .add4(
        requestParameters.name,
        requestParameters.linkForDownload,
        requestParameters.typeLiterature,
        requestParameters.keyWords,
        requestParameters.course,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for delete literature
   * @param {LiteratureControllerApiDeleteById4Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteratureControllerApi
   */
  public deleteById4(
    requestParameters: LiteratureControllerApiDeleteById4Request,
    options?: RawAxiosRequestConfig
  ) {
    return LiteratureControllerApiFp(this.configuration)
      .deleteById4(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for edit literature.
   * @param {LiteratureControllerApiEdit4Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteratureControllerApi
   */
  public edit4(
    requestParameters: LiteratureControllerApiEdit4Request,
    options?: RawAxiosRequestConfig
  ) {
    return LiteratureControllerApiFp(this.configuration)
      .edit4(
        requestParameters.id,
        requestParameters.name,
        requestParameters.linkForDownload,
        requestParameters.typeLiterature,
        requestParameters.keyWords,
        requestParameters.course,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all literature.
   * @param {LiteratureControllerApiGetAll4Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteratureControllerApi
   */
  public getAll4(
    requestParameters: LiteratureControllerApiGetAll4Request,
    options?: RawAxiosRequestConfig
  ) {
    return LiteratureControllerApiFp(this.configuration)
      .getAll4(requestParameters.literatureDtoForFilter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for get literature by id.
   * @param {LiteratureControllerApiGetById1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteratureControllerApi
   */
  public getById1(
    requestParameters: LiteratureControllerApiGetById1Request,
    options?: RawAxiosRequestConfig
  ) {
    return LiteratureControllerApiFp(this.configuration)
      .getById1(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const Add4TypeLiteratureEnum = {
  Book: 'BOOK',
  Link: 'LINK',
} as const
export type Add4TypeLiteratureEnum =
  (typeof Add4TypeLiteratureEnum)[keyof typeof Add4TypeLiteratureEnum]
/**
 * @export
 */
export const Edit4TypeLiteratureEnum = {
  Book: 'BOOK',
  Link: 'LINK',
} as const
export type Edit4TypeLiteratureEnum =
  (typeof Edit4TypeLiteratureEnum)[keyof typeof Edit4TypeLiteratureEnum]

/**
 * ManagerControllerApi - axios parameter creator
 * @export
 */
export const ManagerControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for add  manager.
     * @param {string} name
     * @param {string} lastName
     * @param {string} middleName
     * @param {string} telegram
     * @param {string} telephone
     * @param {string} email
     * @param {number} roleId
     * @param {Add3StatusEnum} status
     * @param {string} [password]
     * @param {File} [image]
     * @param {Array<number>} [courseId]
     * @param {boolean} [display]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add3: async (
      name: string,
      lastName: string,
      middleName: string,
      telegram: string,
      telephone: string,
      email: string,
      roleId: number,
      status: Add3StatusEnum,
      password?: string,
      image?: File,
      courseId?: Array<number>,
      display?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('add3', 'name', name)
      // verify required parameter 'lastName' is not null or undefined
      assertParamExists('add3', 'lastName', lastName)
      // verify required parameter 'middleName' is not null or undefined
      assertParamExists('add3', 'middleName', middleName)
      // verify required parameter 'telegram' is not null or undefined
      assertParamExists('add3', 'telegram', telegram)
      // verify required parameter 'telephone' is not null or undefined
      assertParamExists('add3', 'telephone', telephone)
      // verify required parameter 'email' is not null or undefined
      assertParamExists('add3', 'email', email)
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists('add3', 'roleId', roleId)
      // verify required parameter 'status' is not null or undefined
      assertParamExists('add3', 'status', status)
      const localVarPath = `/api/v1/manager/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (lastName !== undefined) {
        localVarFormParams.append('lastName', lastName as any)
      }

      if (middleName !== undefined) {
        localVarFormParams.append('middleName', middleName as any)
      }

      if (password !== undefined) {
        localVarFormParams.append('password', password as any)
      }

      if (telegram !== undefined) {
        localVarFormParams.append('telegram', telegram as any)
      }

      if (telephone !== undefined) {
        localVarFormParams.append('telephone', telephone as any)
      }

      if (email !== undefined) {
        localVarFormParams.append('email', email as any)
      }

      if (image !== undefined) {
        localVarFormParams.append('image', image as any)
      }
      if (courseId) {
        localVarFormParams.append(
          'courseId',
          courseId.join(COLLECTION_FORMATS.csv)
        )
      }

      if (roleId !== undefined) {
        localVarFormParams.append('roleId', roleId as any)
      }

      if (status !== undefined) {
        localVarFormParams.append('status', status as any)
      }

      if (display !== undefined) {
        localVarFormParams.append('display', String(display) as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for updating page size
     * @param {number} pageSize The number of pages that will be displayed for the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePageSize: async (
      pageSize: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pageSize' is not null or undefined
      assertParamExists('changePageSize', 'pageSize', pageSize)
      const localVarPath = `/api/v1/manager/changePageSize`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for updating theme
     * @param {boolean} theme If value is false theme is light, if value is true theme is dark
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeTheme: async (
      theme: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'theme' is not null or undefined
      assertParamExists('changeTheme', 'theme', theme)
      const localVarPath = `/api/v1/manager/changeTheme`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (theme !== undefined) {
        localVarQueryParameter['theme'] = theme
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request delete manager
     * @param {number} id ID by which the manager is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById3: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteById3', 'id', id)
      const localVarPath = `/api/v1/manager/deleteById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for update manager.
     * @param {number} id id by which the object will be updated
     * @param {string} name
     * @param {string} lastName
     * @param {string} middleName
     * @param {string} telegram
     * @param {string} telephone
     * @param {string} email
     * @param {number} roleId
     * @param {EditStatusEnum} status
     * @param {string} [password]
     * @param {File} [image]
     * @param {Array<number>} [courseId]
     * @param {boolean} [display]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit: async (
      id: number,
      name: string,
      lastName: string,
      middleName: string,
      telegram: string,
      telephone: string,
      email: string,
      roleId: number,
      status: EditStatusEnum,
      password?: string,
      image?: File,
      courseId?: Array<number>,
      display?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('edit', 'id', id)
      // verify required parameter 'name' is not null or undefined
      assertParamExists('edit', 'name', name)
      // verify required parameter 'lastName' is not null or undefined
      assertParamExists('edit', 'lastName', lastName)
      // verify required parameter 'middleName' is not null or undefined
      assertParamExists('edit', 'middleName', middleName)
      // verify required parameter 'telegram' is not null or undefined
      assertParamExists('edit', 'telegram', telegram)
      // verify required parameter 'telephone' is not null or undefined
      assertParamExists('edit', 'telephone', telephone)
      // verify required parameter 'email' is not null or undefined
      assertParamExists('edit', 'email', email)
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists('edit', 'roleId', roleId)
      // verify required parameter 'status' is not null or undefined
      assertParamExists('edit', 'status', status)
      const localVarPath = `/api/v1/manager/edit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (lastName !== undefined) {
        localVarFormParams.append('lastName', lastName as any)
      }

      if (middleName !== undefined) {
        localVarFormParams.append('middleName', middleName as any)
      }

      if (password !== undefined) {
        localVarFormParams.append('password', password as any)
      }

      if (telegram !== undefined) {
        localVarFormParams.append('telegram', telegram as any)
      }

      if (telephone !== undefined) {
        localVarFormParams.append('telephone', telephone as any)
      }

      if (email !== undefined) {
        localVarFormParams.append('email', email as any)
      }

      if (image !== undefined) {
        localVarFormParams.append('image', image as any)
      }
      if (courseId) {
        localVarFormParams.append(
          'courseId',
          courseId.join(COLLECTION_FORMATS.csv)
        )
      }

      if (roleId !== undefined) {
        localVarFormParams.append('roleId', roleId as any)
      }

      if (status !== undefined) {
        localVarFormParams.append('status', status as any)
      }

      if (display !== undefined) {
        localVarFormParams.append('display', String(display) as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all manager.
     * @param {ManagerDtoForFilter} managerDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll3: async (
      managerDtoForFilter: ManagerDtoForFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'managerDtoForFilter' is not null or undefined
      assertParamExists('getAll3', 'managerDtoForFilter', managerDtoForFilter)
      const localVarPath = `/api/v1/manager/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (managerDtoForFilter !== undefined) {
        for (const [key, value] of Object.entries(managerDtoForFilter)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all manager by role id.(ADMIN_ID = 1, MENTOR_ID = 2, MANAGER_ID = 3, SENIOR_MANAGER_ID = 4)
     * @param {number} roleId Role id by which the manager is being deleted
     * @param {number} page Page for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllByRoleId: async (
      roleId: number,
      page: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists('getAllByRoleId', 'roleId', roleId)
      // verify required parameter 'page' is not null or undefined
      assertParamExists('getAllByRoleId', 'page', page)
      const localVarPath = `/api/v1/manager/getAll/byRole`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (roleId !== undefined) {
        localVarQueryParameter['roleId'] = roleId
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting manager by id for edit page
     * @param {number} id ID by which the manager is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForEdit2: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdForEdit2', 'id', id)
      const localVarPath = `/api/v1/manager/getByIdForEdit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting manager by id for information card
     * @param {number} id ID by which the manager is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForView2: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdForView2', 'id', id)
      const localVarPath = `/api/v1/manager/getByIdForView`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageSize: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/manager/getPageSize`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTheme: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/manager/getTheme`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ManagerControllerApi - functional programming interface
 * @export
 */
export const ManagerControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ManagerControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for add  manager.
     * @param {string} name
     * @param {string} lastName
     * @param {string} middleName
     * @param {string} telegram
     * @param {string} telephone
     * @param {string} email
     * @param {number} roleId
     * @param {Add3StatusEnum} status
     * @param {string} [password]
     * @param {File} [image]
     * @param {Array<number>} [courseId]
     * @param {boolean} [display]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add3(
      name: string,
      lastName: string,
      middleName: string,
      telegram: string,
      telephone: string,
      email: string,
      roleId: number,
      status: Add3StatusEnum,
      password?: string,
      image?: File,
      courseId?: Array<number>,
      display?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add3(
        name,
        lastName,
        middleName,
        telegram,
        telephone,
        email,
        roleId,
        status,
        password,
        image,
        courseId,
        display,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.add3']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for updating page size
     * @param {number} pageSize The number of pages that will be displayed for the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePageSize(
      pageSize: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePageSize(
        pageSize,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.changePageSize']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for updating theme
     * @param {boolean} theme If value is false theme is light, if value is true theme is dark
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeTheme(
      theme: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changeTheme(
        theme,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.changeTheme']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request delete manager
     * @param {number} id ID by which the manager is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteById3(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById3(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.deleteById3']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for update manager.
     * @param {number} id id by which the object will be updated
     * @param {string} name
     * @param {string} lastName
     * @param {string} middleName
     * @param {string} telegram
     * @param {string} telephone
     * @param {string} email
     * @param {number} roleId
     * @param {EditStatusEnum} status
     * @param {string} [password]
     * @param {File} [image]
     * @param {Array<number>} [courseId]
     * @param {boolean} [display]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async edit(
      id: number,
      name: string,
      lastName: string,
      middleName: string,
      telegram: string,
      telephone: string,
      email: string,
      roleId: number,
      status: EditStatusEnum,
      password?: string,
      image?: File,
      courseId?: Array<number>,
      display?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.edit(
        id,
        name,
        lastName,
        middleName,
        telegram,
        telephone,
        email,
        roleId,
        status,
        password,
        image,
        courseId,
        display,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.edit']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all manager.
     * @param {ManagerDtoForFilter} managerDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll3(
      managerDtoForFilter: ManagerDtoForFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageManagerDtoForView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll3(
        managerDtoForFilter,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.getAll3']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all manager by role id.(ADMIN_ID = 1, MENTOR_ID = 2, MANAGER_ID = 3, SENIOR_MANAGER_ID = 4)
     * @param {number} roleId Role id by which the manager is being deleted
     * @param {number} page Page for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllByRoleId(
      roleId: number,
      page: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageManagerDtoForView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllByRoleId(
        roleId,
        page,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.getAllByRoleId']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting manager by id for edit page
     * @param {number} id ID by which the manager is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdForEdit2(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ManagerDtoForAdd>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdForEdit2(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.getByIdForEdit2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting manager by id for information card
     * @param {number} id ID by which the manager is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdForView2(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ManagerDtoForCard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdForView2(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.getByIdForView2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageSize(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageSize(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.getPageSize']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTheme(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTheme(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManagerControllerApi.getTheme']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ManagerControllerApi - factory interface
 * @export
 */
export const ManagerControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ManagerControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for add  manager.
     * @param {ManagerControllerApiAdd3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add3(
      requestParameters: ManagerControllerApiAdd3Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .add3(
          requestParameters.name,
          requestParameters.lastName,
          requestParameters.middleName,
          requestParameters.telegram,
          requestParameters.telephone,
          requestParameters.email,
          requestParameters.roleId,
          requestParameters.status,
          requestParameters.password,
          requestParameters.image,
          requestParameters.courseId,
          requestParameters.display,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for updating page size
     * @param {ManagerControllerApiChangePageSizeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePageSize(
      requestParameters: ManagerControllerApiChangePageSizeRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .changePageSize(requestParameters.pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for updating theme
     * @param {ManagerControllerApiChangeThemeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeTheme(
      requestParameters: ManagerControllerApiChangeThemeRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .changeTheme(requestParameters.theme, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request delete manager
     * @param {ManagerControllerApiDeleteById3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById3(
      requestParameters: ManagerControllerApiDeleteById3Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .deleteById3(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for update manager.
     * @param {ManagerControllerApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(
      requestParameters: ManagerControllerApiEditRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .edit(
          requestParameters.id,
          requestParameters.name,
          requestParameters.lastName,
          requestParameters.middleName,
          requestParameters.telegram,
          requestParameters.telephone,
          requestParameters.email,
          requestParameters.roleId,
          requestParameters.status,
          requestParameters.password,
          requestParameters.image,
          requestParameters.courseId,
          requestParameters.display,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all manager.
     * @param {ManagerControllerApiGetAll3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll3(
      requestParameters: ManagerControllerApiGetAll3Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageManagerDtoForView> {
      return localVarFp
        .getAll3(requestParameters.managerDtoForFilter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all manager by role id.(ADMIN_ID = 1, MENTOR_ID = 2, MANAGER_ID = 3, SENIOR_MANAGER_ID = 4)
     * @param {ManagerControllerApiGetAllByRoleIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllByRoleId(
      requestParameters: ManagerControllerApiGetAllByRoleIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageManagerDtoForView> {
      return localVarFp
        .getAllByRoleId(
          requestParameters.roleId,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting manager by id for edit page
     * @param {ManagerControllerApiGetByIdForEdit2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForEdit2(
      requestParameters: ManagerControllerApiGetByIdForEdit2Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ManagerDtoForAdd> {
      return localVarFp
        .getByIdForEdit2(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting manager by id for information card
     * @param {ManagerControllerApiGetByIdForView2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForView2(
      requestParameters: ManagerControllerApiGetByIdForView2Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ManagerDtoForCard> {
      return localVarFp
        .getByIdForView2(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageSize(options?: RawAxiosRequestConfig): AxiosPromise<number> {
      return localVarFp
        .getPageSize(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTheme(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
      return localVarFp
        .getTheme(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for add3 operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiAdd3Request
 */
export interface ManagerControllerApiAdd3Request {
  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiAdd3
   */
  readonly name: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiAdd3
   */
  readonly lastName: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiAdd3
   */
  readonly middleName: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiAdd3
   */
  readonly telegram: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiAdd3
   */
  readonly telephone: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiAdd3
   */
  readonly email: string

  /**
   *
   * @type {number}
   * @memberof ManagerControllerApiAdd3
   */
  readonly roleId: number

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiAdd3
   */
  readonly status: Add3StatusEnum

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiAdd3
   */
  readonly password?: string

  /**
   *
   * @type {File}
   * @memberof ManagerControllerApiAdd3
   */
  readonly image?: File

  /**
   *
   * @type {Array<number>}
   * @memberof ManagerControllerApiAdd3
   */
  readonly courseId?: Array<number>

  /**
   *
   * @type {boolean}
   * @memberof ManagerControllerApiAdd3
   */
  readonly display?: boolean
}

/**
 * Request parameters for changePageSize operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiChangePageSizeRequest
 */
export interface ManagerControllerApiChangePageSizeRequest {
  /**
   * The number of pages that will be displayed for the authorized user
   * @type {number}
   * @memberof ManagerControllerApiChangePageSize
   */
  readonly pageSize: number
}

/**
 * Request parameters for changeTheme operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiChangeThemeRequest
 */
export interface ManagerControllerApiChangeThemeRequest {
  /**
   * If value is false theme is light, if value is true theme is dark
   * @type {boolean}
   * @memberof ManagerControllerApiChangeTheme
   */
  readonly theme: boolean
}

/**
 * Request parameters for deleteById3 operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiDeleteById3Request
 */
export interface ManagerControllerApiDeleteById3Request {
  /**
   * ID by which the manager is being deleted
   * @type {number}
   * @memberof ManagerControllerApiDeleteById3
   */
  readonly id: number
}

/**
 * Request parameters for edit operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiEditRequest
 */
export interface ManagerControllerApiEditRequest {
  /**
   * id by which the object will be updated
   * @type {number}
   * @memberof ManagerControllerApiEdit
   */
  readonly id: number

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiEdit
   */
  readonly name: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiEdit
   */
  readonly lastName: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiEdit
   */
  readonly middleName: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiEdit
   */
  readonly telegram: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiEdit
   */
  readonly telephone: string

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiEdit
   */
  readonly email: string

  /**
   *
   * @type {number}
   * @memberof ManagerControllerApiEdit
   */
  readonly roleId: number

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiEdit
   */
  readonly status: EditStatusEnum

  /**
   *
   * @type {string}
   * @memberof ManagerControllerApiEdit
   */
  readonly password?: string

  /**
   *
   * @type {File}
   * @memberof ManagerControllerApiEdit
   */
  readonly image?: File

  /**
   *
   * @type {Array<number>}
   * @memberof ManagerControllerApiEdit
   */
  readonly courseId?: Array<number>

  /**
   *
   * @type {boolean}
   * @memberof ManagerControllerApiEdit
   */
  readonly display?: boolean
}

/**
 * Request parameters for getAll3 operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiGetAll3Request
 */
export interface ManagerControllerApiGetAll3Request {
  /**
   * DTO for filter date. This DTO also has date for pagination
   * @type {ManagerDtoForFilter}
   * @memberof ManagerControllerApiGetAll3
   */
  readonly managerDtoForFilter: ManagerDtoForFilter
}

/**
 * Request parameters for getAllByRoleId operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiGetAllByRoleIdRequest
 */
export interface ManagerControllerApiGetAllByRoleIdRequest {
  /**
   * Role id by which the manager is being deleted
   * @type {number}
   * @memberof ManagerControllerApiGetAllByRoleId
   */
  readonly roleId: number

  /**
   * Page for pagination
   * @type {number}
   * @memberof ManagerControllerApiGetAllByRoleId
   */
  readonly page: number
}

/**
 * Request parameters for getByIdForEdit2 operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiGetByIdForEdit2Request
 */
export interface ManagerControllerApiGetByIdForEdit2Request {
  /**
   * ID by which the manager is being searched
   * @type {number}
   * @memberof ManagerControllerApiGetByIdForEdit2
   */
  readonly id: number
}

/**
 * Request parameters for getByIdForView2 operation in ManagerControllerApi.
 * @export
 * @interface ManagerControllerApiGetByIdForView2Request
 */
export interface ManagerControllerApiGetByIdForView2Request {
  /**
   * ID by which the manager is being searched
   * @type {number}
   * @memberof ManagerControllerApiGetByIdForView2
   */
  readonly id: number
}

/**
 * ManagerControllerApi - object-oriented interface
 * @export
 * @class ManagerControllerApi
 * @extends {BaseAPI}
 */
export class ManagerControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for add  manager.
   * @param {ManagerControllerApiAdd3Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public add3(
    requestParameters: ManagerControllerApiAdd3Request,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .add3(
        requestParameters.name,
        requestParameters.lastName,
        requestParameters.middleName,
        requestParameters.telegram,
        requestParameters.telephone,
        requestParameters.email,
        requestParameters.roleId,
        requestParameters.status,
        requestParameters.password,
        requestParameters.image,
        requestParameters.courseId,
        requestParameters.display,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for updating page size
   * @param {ManagerControllerApiChangePageSizeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public changePageSize(
    requestParameters: ManagerControllerApiChangePageSizeRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .changePageSize(requestParameters.pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for updating theme
   * @param {ManagerControllerApiChangeThemeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public changeTheme(
    requestParameters: ManagerControllerApiChangeThemeRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .changeTheme(requestParameters.theme, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request delete manager
   * @param {ManagerControllerApiDeleteById3Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public deleteById3(
    requestParameters: ManagerControllerApiDeleteById3Request,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .deleteById3(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for update manager.
   * @param {ManagerControllerApiEditRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public edit(
    requestParameters: ManagerControllerApiEditRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .edit(
        requestParameters.id,
        requestParameters.name,
        requestParameters.lastName,
        requestParameters.middleName,
        requestParameters.telegram,
        requestParameters.telephone,
        requestParameters.email,
        requestParameters.roleId,
        requestParameters.status,
        requestParameters.password,
        requestParameters.image,
        requestParameters.courseId,
        requestParameters.display,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all manager.
   * @param {ManagerControllerApiGetAll3Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public getAll3(
    requestParameters: ManagerControllerApiGetAll3Request,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .getAll3(requestParameters.managerDtoForFilter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all manager by role id.(ADMIN_ID = 1, MENTOR_ID = 2, MANAGER_ID = 3, SENIOR_MANAGER_ID = 4)
   * @param {ManagerControllerApiGetAllByRoleIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public getAllByRoleId(
    requestParameters: ManagerControllerApiGetAllByRoleIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .getAllByRoleId(requestParameters.roleId, requestParameters.page, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting manager by id for edit page
   * @param {ManagerControllerApiGetByIdForEdit2Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public getByIdForEdit2(
    requestParameters: ManagerControllerApiGetByIdForEdit2Request,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .getByIdForEdit2(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting manager by id for information card
   * @param {ManagerControllerApiGetByIdForView2Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public getByIdForView2(
    requestParameters: ManagerControllerApiGetByIdForView2Request,
    options?: RawAxiosRequestConfig
  ) {
    return ManagerControllerApiFp(this.configuration)
      .getByIdForView2(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting page size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public getPageSize(options?: RawAxiosRequestConfig) {
    return ManagerControllerApiFp(this.configuration)
      .getPageSize(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagerControllerApi
   */
  public getTheme(options?: RawAxiosRequestConfig) {
    return ManagerControllerApiFp(this.configuration)
      .getTheme(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const Add3StatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const
export type Add3StatusEnum =
  (typeof Add3StatusEnum)[keyof typeof Add3StatusEnum]
/**
 * @export
 */
export const EditStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const
export type EditStatusEnum =
  (typeof EditStatusEnum)[keyof typeof EditStatusEnum]

/**
 * RoleControllerApi - axios parameter creator
 * @export
 */
export const RoleControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for add role.
     * @param {string} name
     * @param {string} nameEng
     * @param {string} nameUkr
     * @param {Array<Add2PagesEnum>} [pages]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add2: async (
      name: string,
      nameEng: string,
      nameUkr: string,
      pages?: Array<Add2PagesEnum>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('add2', 'name', name)
      // verify required parameter 'nameEng' is not null or undefined
      assertParamExists('add2', 'nameEng', nameEng)
      // verify required parameter 'nameUkr' is not null or undefined
      assertParamExists('add2', 'nameUkr', nameUkr)
      const localVarPath = `/api/v1/role/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (nameEng !== undefined) {
        localVarFormParams.append('nameEng', nameEng as any)
      }

      if (nameUkr !== undefined) {
        localVarFormParams.append('nameUkr', nameUkr as any)
      }
      if (pages) {
        localVarFormParams.append('pages', pages.join(COLLECTION_FORMATS.csv))
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for delete role
     * @param {number} id ID by which the role is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById2: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteById2', 'id', id)
      const localVarPath = `/api/v1/role/deleteById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for edit role.
     * @param {number} id ID by which the role is being edited
     * @param {string} name
     * @param {string} nameEng
     * @param {string} nameUkr
     * @param {Array<Edit3PagesEnum>} [pages]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit3: async (
      id: number,
      name: string,
      nameEng: string,
      nameUkr: string,
      pages?: Array<Edit3PagesEnum>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('edit3', 'id', id)
      // verify required parameter 'name' is not null or undefined
      assertParamExists('edit3', 'name', name)
      // verify required parameter 'nameEng' is not null or undefined
      assertParamExists('edit3', 'nameEng', nameEng)
      // verify required parameter 'nameUkr' is not null or undefined
      assertParamExists('edit3', 'nameUkr', nameUkr)
      const localVarPath = `/api/v1/role/edit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (nameEng !== undefined) {
        localVarFormParams.append('nameEng', nameEng as any)
      }

      if (nameUkr !== undefined) {
        localVarFormParams.append('nameUkr', nameUkr as any)
      }
      if (pages) {
        localVarFormParams.append('pages', pages.join(COLLECTION_FORMATS.csv))
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all roles.
     * @param {RoleDtoFilter} roleDtoFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll2: async (
      roleDtoFilter: RoleDtoFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'roleDtoFilter' is not null or undefined
      assertParamExists('getAll2', 'roleDtoFilter', roleDtoFilter)
      const localVarPath = `/api/v1/role/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (roleDtoFilter !== undefined) {
        for (const [key, value] of Object.entries(roleDtoFilter)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for get role by id.
     * @param {number} id ID by which the role is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getById', 'id', id)
      const localVarPath = `/api/v1/role/getById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RoleControllerApi - functional programming interface
 * @export
 */
export const RoleControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RoleControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for add role.
     * @param {string} name
     * @param {string} nameEng
     * @param {string} nameUkr
     * @param {Array<Add2PagesEnum>} [pages]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add2(
      name: string,
      nameEng: string,
      nameUkr: string,
      pages?: Array<Add2PagesEnum>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add2(
        name,
        nameEng,
        nameUkr,
        pages,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RoleControllerApi.add2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for delete role
     * @param {number} id ID by which the role is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteById2(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById2(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RoleControllerApi.deleteById2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for edit role.
     * @param {number} id ID by which the role is being edited
     * @param {string} name
     * @param {string} nameEng
     * @param {string} nameUkr
     * @param {Array<Edit3PagesEnum>} [pages]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async edit3(
      id: number,
      name: string,
      nameEng: string,
      nameUkr: string,
      pages?: Array<Edit3PagesEnum>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.edit3(
        id,
        name,
        nameEng,
        nameUkr,
        pages,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RoleControllerApi.edit3']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all roles.
     * @param {RoleDtoFilter} roleDtoFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll2(
      roleDtoFilter: RoleDtoFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageRoleDtoView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll2(
        roleDtoFilter,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RoleControllerApi.getAll2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for get role by id.
     * @param {number} id ID by which the role is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getById(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getById(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RoleControllerApi.getById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * RoleControllerApi - factory interface
 * @export
 */
export const RoleControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RoleControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for add role.
     * @param {RoleControllerApiAdd2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add2(
      requestParameters: RoleControllerApiAdd2Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .add2(
          requestParameters.name,
          requestParameters.nameEng,
          requestParameters.nameUkr,
          requestParameters.pages,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for delete role
     * @param {RoleControllerApiDeleteById2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById2(
      requestParameters: RoleControllerApiDeleteById2Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .deleteById2(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for edit role.
     * @param {RoleControllerApiEdit3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit3(
      requestParameters: RoleControllerApiEdit3Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .edit3(
          requestParameters.id,
          requestParameters.name,
          requestParameters.nameEng,
          requestParameters.nameUkr,
          requestParameters.pages,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all roles.
     * @param {RoleControllerApiGetAll2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll2(
      requestParameters: RoleControllerApiGetAll2Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageRoleDtoView> {
      return localVarFp
        .getAll2(requestParameters.roleDtoFilter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for get role by id.
     * @param {RoleControllerApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById(
      requestParameters: RoleControllerApiGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Role> {
      return localVarFp
        .getById(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for add2 operation in RoleControllerApi.
 * @export
 * @interface RoleControllerApiAdd2Request
 */
export interface RoleControllerApiAdd2Request {
  /**
   *
   * @type {string}
   * @memberof RoleControllerApiAdd2
   */
  readonly name: string

  /**
   *
   * @type {string}
   * @memberof RoleControllerApiAdd2
   */
  readonly nameEng: string

  /**
   *
   * @type {string}
   * @memberof RoleControllerApiAdd2
   */
  readonly nameUkr: string

  /**
   *
   * @type {Array<string>}
   * @memberof RoleControllerApiAdd2
   */
  readonly pages?: Array<Add2PagesEnum>
}

/**
 * Request parameters for deleteById2 operation in RoleControllerApi.
 * @export
 * @interface RoleControllerApiDeleteById2Request
 */
export interface RoleControllerApiDeleteById2Request {
  /**
   * ID by which the role is being deleted
   * @type {number}
   * @memberof RoleControllerApiDeleteById2
   */
  readonly id: number
}

/**
 * Request parameters for edit3 operation in RoleControllerApi.
 * @export
 * @interface RoleControllerApiEdit3Request
 */
export interface RoleControllerApiEdit3Request {
  /**
   * ID by which the role is being edited
   * @type {number}
   * @memberof RoleControllerApiEdit3
   */
  readonly id: number

  /**
   *
   * @type {string}
   * @memberof RoleControllerApiEdit3
   */
  readonly name: string

  /**
   *
   * @type {string}
   * @memberof RoleControllerApiEdit3
   */
  readonly nameEng: string

  /**
   *
   * @type {string}
   * @memberof RoleControllerApiEdit3
   */
  readonly nameUkr: string

  /**
   *
   * @type {Array<string>}
   * @memberof RoleControllerApiEdit3
   */
  readonly pages?: Array<Edit3PagesEnum>
}

/**
 * Request parameters for getAll2 operation in RoleControllerApi.
 * @export
 * @interface RoleControllerApiGetAll2Request
 */
export interface RoleControllerApiGetAll2Request {
  /**
   * DTO for filter date. This DTO also has date for pagination
   * @type {RoleDtoFilter}
   * @memberof RoleControllerApiGetAll2
   */
  readonly roleDtoFilter: RoleDtoFilter
}

/**
 * Request parameters for getById operation in RoleControllerApi.
 * @export
 * @interface RoleControllerApiGetByIdRequest
 */
export interface RoleControllerApiGetByIdRequest {
  /**
   * ID by which the role is being searched
   * @type {number}
   * @memberof RoleControllerApiGetById
   */
  readonly id: number
}

/**
 * RoleControllerApi - object-oriented interface
 * @export
 * @class RoleControllerApi
 * @extends {BaseAPI}
 */
export class RoleControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for add role.
   * @param {RoleControllerApiAdd2Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleControllerApi
   */
  public add2(
    requestParameters: RoleControllerApiAdd2Request,
    options?: RawAxiosRequestConfig
  ) {
    return RoleControllerApiFp(this.configuration)
      .add2(
        requestParameters.name,
        requestParameters.nameEng,
        requestParameters.nameUkr,
        requestParameters.pages,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for delete role
   * @param {RoleControllerApiDeleteById2Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleControllerApi
   */
  public deleteById2(
    requestParameters: RoleControllerApiDeleteById2Request,
    options?: RawAxiosRequestConfig
  ) {
    return RoleControllerApiFp(this.configuration)
      .deleteById2(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for edit role.
   * @param {RoleControllerApiEdit3Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleControllerApi
   */
  public edit3(
    requestParameters: RoleControllerApiEdit3Request,
    options?: RawAxiosRequestConfig
  ) {
    return RoleControllerApiFp(this.configuration)
      .edit3(
        requestParameters.id,
        requestParameters.name,
        requestParameters.nameEng,
        requestParameters.nameUkr,
        requestParameters.pages,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all roles.
   * @param {RoleControllerApiGetAll2Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleControllerApi
   */
  public getAll2(
    requestParameters: RoleControllerApiGetAll2Request,
    options?: RawAxiosRequestConfig
  ) {
    return RoleControllerApiFp(this.configuration)
      .getAll2(requestParameters.roleDtoFilter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for get role by id.
   * @param {RoleControllerApiGetByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleControllerApi
   */
  public getById(
    requestParameters: RoleControllerApiGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return RoleControllerApiFp(this.configuration)
      .getById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const Add2PagesEnum = {
  Statistic: 'STATISTIC',
  Task: 'TASK',
  Student: 'STUDENT',
  Course: 'COURSE',
  Lesson: 'LESSON',
  Literature: 'LITERATURE',
  Role: 'ROLE',
  Test: 'TEST',
  Contact: 'CONTACT',
} as const
export type Add2PagesEnum = (typeof Add2PagesEnum)[keyof typeof Add2PagesEnum]
/**
 * @export
 */
export const Edit3PagesEnum = {
  Statistic: 'STATISTIC',
  Task: 'TASK',
  Student: 'STUDENT',
  Course: 'COURSE',
  Lesson: 'LESSON',
  Literature: 'LITERATURE',
  Role: 'ROLE',
  Test: 'TEST',
  Contact: 'CONTACT',
} as const
export type Edit3PagesEnum =
  (typeof Edit3PagesEnum)[keyof typeof Edit3PagesEnum]

/**
 * StatisticControllerApi - axios parameter creator
 * @export
 */
export const StatisticControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for getting all top student by courses, or getting all top students if courses is null.
     * @param {number} arg1 Page for pagination
     * @param {number} arg2 Page size for pagination
     * @param {number} [courseId] Course\&#39;s id by which the students is searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTopStudent: async (
      arg1: number,
      arg2: number,
      courseId?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'arg1' is not null or undefined
      assertParamExists('getAllTopStudent', 'arg1', arg1)
      // verify required parameter 'arg2' is not null or undefined
      assertParamExists('getAllTopStudent', 'arg2', arg2)
      const localVarPath = `/api/v1/statistic/getAllTopStudents`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (courseId !== undefined) {
        localVarQueryParameter['courseId'] = courseId
      }

      if (arg1 !== undefined) {
        localVarQueryParameter['arg1'] = arg1
      }

      if (arg2 !== undefined) {
        localVarQueryParameter['arg2'] = arg2
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all widgets for statistic page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllWidgets: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/statistic/getAllWidgets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all average grade by date.
     * @param {number} [courseId] Course id is not necessary. If courses is null the request will returned all data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAverageGradeByDate: async (
      courseId?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/statistic/getAverageGradeByDate`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (courseId !== undefined) {
        localVarQueryParameter['courseId'] = courseId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StatisticControllerApi - functional programming interface
 * @export
 */
export const StatisticControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    StatisticControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for getting all top student by courses, or getting all top students if courses is null.
     * @param {number} arg1 Page for pagination
     * @param {number} arg2 Page size for pagination
     * @param {number} [courseId] Course\&#39;s id by which the students is searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllTopStudent(
      arg1: number,
      arg2: number,
      courseId?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageStudentDtoForStatistic>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllTopStudent(
          arg1,
          arg2,
          courseId,
          options
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatisticControllerApi.getAllTopStudent']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all widgets for statistic page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllWidgets(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWidgets(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatisticControllerApi.getAllWidgets']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all average grade by date.
     * @param {number} [courseId] Course id is not necessary. If courses is null the request will returned all data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAverageGradeByDate(
      courseId?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAverageGradeByDate(courseId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatisticControllerApi.getAverageGradeByDate']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * StatisticControllerApi - factory interface
 * @export
 */
export const StatisticControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StatisticControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for getting all top student by courses, or getting all top students if courses is null.
     * @param {StatisticControllerApiGetAllTopStudentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTopStudent(
      requestParameters: StatisticControllerApiGetAllTopStudentRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageStudentDtoForStatistic> {
      return localVarFp
        .getAllTopStudent(
          requestParameters.arg1,
          requestParameters.arg2,
          requestParameters.courseId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all widgets for statistic page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllWidgets(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getAllWidgets(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all average grade by date.
     * @param {StatisticControllerApiGetAverageGradeByDateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAverageGradeByDate(
      requestParameters: StatisticControllerApiGetAverageGradeByDateRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getAverageGradeByDate(requestParameters.courseId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for getAllTopStudent operation in StatisticControllerApi.
 * @export
 * @interface StatisticControllerApiGetAllTopStudentRequest
 */
export interface StatisticControllerApiGetAllTopStudentRequest {
  /**
   * Page for pagination
   * @type {number}
   * @memberof StatisticControllerApiGetAllTopStudent
   */
  readonly arg1: number

  /**
   * Page size for pagination
   * @type {number}
   * @memberof StatisticControllerApiGetAllTopStudent
   */
  readonly arg2: number

  /**
   * Course\&#39;s id by which the students is searched
   * @type {number}
   * @memberof StatisticControllerApiGetAllTopStudent
   */
  readonly courseId?: number
}

/**
 * Request parameters for getAverageGradeByDate operation in StatisticControllerApi.
 * @export
 * @interface StatisticControllerApiGetAverageGradeByDateRequest
 */
export interface StatisticControllerApiGetAverageGradeByDateRequest {
  /**
   * Course id is not necessary. If courses is null the request will returned all data
   * @type {number}
   * @memberof StatisticControllerApiGetAverageGradeByDate
   */
  readonly courseId?: number
}

/**
 * StatisticControllerApi - object-oriented interface
 * @export
 * @class StatisticControllerApi
 * @extends {BaseAPI}
 */
export class StatisticControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for getting all top student by courses, or getting all top students if courses is null.
   * @param {StatisticControllerApiGetAllTopStudentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticControllerApi
   */
  public getAllTopStudent(
    requestParameters: StatisticControllerApiGetAllTopStudentRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StatisticControllerApiFp(this.configuration)
      .getAllTopStudent(
        requestParameters.arg1,
        requestParameters.arg2,
        requestParameters.courseId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all widgets for statistic page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticControllerApi
   */
  public getAllWidgets(options?: RawAxiosRequestConfig) {
    return StatisticControllerApiFp(this.configuration)
      .getAllWidgets(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all average grade by date.
   * @param {StatisticControllerApiGetAverageGradeByDateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticControllerApi
   */
  public getAverageGradeByDate(
    requestParameters: StatisticControllerApiGetAverageGradeByDateRequest = {},
    options?: RawAxiosRequestConfig
  ) {
    return StatisticControllerApiFp(this.configuration)
      .getAverageGradeByDate(requestParameters.courseId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StudentControllerApi - axios parameter creator
 * @export
 */
export const StudentControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for add some student.
     * @param {string} email
     * @param {string} [name]
     * @param {string} [lastName]
     * @param {string} [middleName]
     * @param {boolean} [isVideoReview]
     * @param {string} [telegram]
     * @param {string} [telephone]
     * @param {File} [image]
     * @param {string} [oldImageName]
     * @param {string} [birthday]
     * @param {number} [totalMark]
     * @param {Array<string>} [education]
     * @param {Add1CurrentSituationEnum} [currentSituation]
     * @param {Add1LevelOfPreparationEnum} [levelOfPreparation]
     * @param {Add1EnglishLevelEnum} [englishLevel]
     * @param {Add1StatusEnum} [status]
     * @param {number} [courseId]
     * @param {string} [work]
     * @param {boolean} [display]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add1: async (
      email: string,
      name?: string,
      lastName?: string,
      middleName?: string,
      isVideoReview?: boolean,
      telegram?: string,
      telephone?: string,
      image?: File,
      oldImageName?: string,
      birthday?: string,
      totalMark?: number,
      education?: Array<string>,
      currentSituation?: Add1CurrentSituationEnum,
      levelOfPreparation?: Add1LevelOfPreparationEnum,
      englishLevel?: Add1EnglishLevelEnum,
      status?: Add1StatusEnum,
      courseId?: number,
      work?: string,
      display?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('add1', 'email', email)
      const localVarPath = `/api/v1/student/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (lastName !== undefined) {
        localVarFormParams.append('lastName', lastName as any)
      }

      if (middleName !== undefined) {
        localVarFormParams.append('middleName', middleName as any)
      }

      if (isVideoReview !== undefined) {
        localVarFormParams.append('isVideoReview', String(isVideoReview) as any)
      }

      if (telegram !== undefined) {
        localVarFormParams.append('telegram', telegram as any)
      }

      if (telephone !== undefined) {
        localVarFormParams.append('telephone', telephone as any)
      }

      if (email !== undefined) {
        localVarFormParams.append('email', email as any)
      }

      if (image !== undefined) {
        localVarFormParams.append('image', image as any)
      }

      if (oldImageName !== undefined) {
        localVarFormParams.append('oldImageName', oldImageName as any)
      }

      if (birthday !== undefined) {
        localVarFormParams.append('birthday', birthday as any)
      }

      if (totalMark !== undefined) {
        localVarFormParams.append('totalMark', totalMark as any)
      }
      if (education) {
        localVarFormParams.append(
          'education',
          education.join(COLLECTION_FORMATS.csv)
        )
      }

      if (currentSituation !== undefined) {
        localVarFormParams.append('currentSituation', currentSituation as any)
      }

      if (levelOfPreparation !== undefined) {
        localVarFormParams.append(
          'levelOfPreparation',
          levelOfPreparation as any
        )
      }

      if (englishLevel !== undefined) {
        localVarFormParams.append('englishLevel', englishLevel as any)
      }

      if (status !== undefined) {
        localVarFormParams.append('status', status as any)
      }

      if (courseId !== undefined) {
        localVarFormParams.append('courseId', courseId as any)
      }

      if (work !== undefined) {
        localVarFormParams.append('work', work as any)
      }

      if (display !== undefined) {
        localVarFormParams.append('display', String(display) as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for change current task.
     * @param {number} taskId id for the new current task for the student
     * @param {number} studentId student\&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeCurrentTask: async (
      taskId: number,
      studentId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('changeCurrentTask', 'taskId', taskId)
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('changeCurrentTask', 'studentId', studentId)
      const localVarPath = `/api/v1/student/task/change`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (taskId !== undefined) {
        localVarQueryParameter['taskId'] = taskId
      }

      if (studentId !== undefined) {
        localVarQueryParameter['studentId'] = studentId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for delete some student by id
     * @param {number} id ID by which the student is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById1: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteById1', 'id', id)
      const localVarPath = `/api/v1/student/deleteById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for update some student.
     * @param {number} id id by which the object will be updated
     * @param {string} email
     * @param {string} [newPassword]
     * @param {string} [name]
     * @param {string} [lastName]
     * @param {string} [middleName]
     * @param {boolean} [isVideoReview]
     * @param {string} [telegram]
     * @param {string} [telephone]
     * @param {File} [image]
     * @param {string} [oldImageName]
     * @param {string} [birthday]
     * @param {number} [totalMark]
     * @param {Array<string>} [education]
     * @param {Edit2CurrentSituationEnum} [currentSituation]
     * @param {Edit2LevelOfPreparationEnum} [levelOfPreparation]
     * @param {Edit2EnglishLevelEnum} [englishLevel]
     * @param {Edit2StatusEnum} [status]
     * @param {number} [courseId]
     * @param {string} [work]
     * @param {boolean} [display]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit2: async (
      id: number,
      email: string,
      newPassword?: string,
      name?: string,
      lastName?: string,
      middleName?: string,
      isVideoReview?: boolean,
      telegram?: string,
      telephone?: string,
      image?: File,
      oldImageName?: string,
      birthday?: string,
      totalMark?: number,
      education?: Array<string>,
      currentSituation?: Edit2CurrentSituationEnum,
      levelOfPreparation?: Edit2LevelOfPreparationEnum,
      englishLevel?: Edit2EnglishLevelEnum,
      status?: Edit2StatusEnum,
      courseId?: number,
      work?: string,
      display?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('edit2', 'id', id)
      // verify required parameter 'email' is not null or undefined
      assertParamExists('edit2', 'email', email)
      const localVarPath = `/api/v1/student/edit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (newPassword !== undefined) {
        localVarQueryParameter['newPassword'] = newPassword
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (lastName !== undefined) {
        localVarFormParams.append('lastName', lastName as any)
      }

      if (middleName !== undefined) {
        localVarFormParams.append('middleName', middleName as any)
      }

      if (isVideoReview !== undefined) {
        localVarFormParams.append('isVideoReview', String(isVideoReview) as any)
      }

      if (telegram !== undefined) {
        localVarFormParams.append('telegram', telegram as any)
      }

      if (telephone !== undefined) {
        localVarFormParams.append('telephone', telephone as any)
      }

      if (email !== undefined) {
        localVarFormParams.append('email', email as any)
      }

      if (image !== undefined) {
        localVarFormParams.append('image', image as any)
      }

      if (oldImageName !== undefined) {
        localVarFormParams.append('oldImageName', oldImageName as any)
      }

      if (birthday !== undefined) {
        localVarFormParams.append('birthday', birthday as any)
      }

      if (totalMark !== undefined) {
        localVarFormParams.append('totalMark', totalMark as any)
      }
      if (education) {
        localVarFormParams.append(
          'education',
          education.join(COLLECTION_FORMATS.csv)
        )
      }

      if (currentSituation !== undefined) {
        localVarFormParams.append('currentSituation', currentSituation as any)
      }

      if (levelOfPreparation !== undefined) {
        localVarFormParams.append(
          'levelOfPreparation',
          levelOfPreparation as any
        )
      }

      if (englishLevel !== undefined) {
        localVarFormParams.append('englishLevel', englishLevel as any)
      }

      if (status !== undefined) {
        localVarFormParams.append('status', status as any)
      }

      if (courseId !== undefined) {
        localVarFormParams.append('courseId', courseId as any)
      }

      if (work !== undefined) {
        localVarFormParams.append('work', work as any)
      }

      if (display !== undefined) {
        localVarFormParams.append('display', String(display) as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all students.
     * @param {StudentDtoForFilter} studentDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll1: async (
      studentDtoForFilter: StudentDtoForFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentDtoForFilter' is not null or undefined
      assertParamExists('getAll1', 'studentDtoForFilter', studentDtoForFilter)
      const localVarPath = `/api/v1/student/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (studentDtoForFilter !== undefined) {
        for (const [key, value] of Object.entries(studentDtoForFilter)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all student\'s tasks by student id.
     * @param {number} studentId ID by which the student\&#39;s tasks are being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllStudentTasks: async (
      studentId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists('getAllStudentTasks', 'studentId', studentId)
      const localVarPath = `/api/v1/student/task/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (studentId !== undefined) {
        localVarQueryParameter['studentId'] = studentId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting student by id for edit page
     * @param {number} id ID by which the student is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForEdit1: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdForEdit1', 'id', id)
      const localVarPath = `/api/v1/student/getByIdForEdit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting student by id for information card
     * @param {number} id ID by which the student is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForView1: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdForView1', 'id', id)
      const localVarPath = `/api/v1/student/getByIdForView`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for update current task.
     * @param {StudentTasksDto} studentTasksDto Dto for update current student\&#39;s task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentTask: async (
      studentTasksDto: StudentTasksDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentTasksDto' is not null or undefined
      assertParamExists('updateCurrentTask', 'studentTasksDto', studentTasksDto)
      const localVarPath = `/api/v1/student/task/update`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentTasksDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StudentControllerApi - functional programming interface
 * @export
 */
export const StudentControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    StudentControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for add some student.
     * @param {string} email
     * @param {string} [name]
     * @param {string} [lastName]
     * @param {string} [middleName]
     * @param {boolean} [isVideoReview]
     * @param {string} [telegram]
     * @param {string} [telephone]
     * @param {File} [image]
     * @param {string} [oldImageName]
     * @param {string} [birthday]
     * @param {number} [totalMark]
     * @param {Array<string>} [education]
     * @param {Add1CurrentSituationEnum} [currentSituation]
     * @param {Add1LevelOfPreparationEnum} [levelOfPreparation]
     * @param {Add1EnglishLevelEnum} [englishLevel]
     * @param {Add1StatusEnum} [status]
     * @param {number} [courseId]
     * @param {string} [work]
     * @param {boolean} [display]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add1(
      email: string,
      name?: string,
      lastName?: string,
      middleName?: string,
      isVideoReview?: boolean,
      telegram?: string,
      telephone?: string,
      image?: File,
      oldImageName?: string,
      birthday?: string,
      totalMark?: number,
      education?: Array<string>,
      currentSituation?: Add1CurrentSituationEnum,
      levelOfPreparation?: Add1LevelOfPreparationEnum,
      englishLevel?: Add1EnglishLevelEnum,
      status?: Add1StatusEnum,
      courseId?: number,
      work?: string,
      display?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add1(
        email,
        name,
        lastName,
        middleName,
        isVideoReview,
        telegram,
        telephone,
        image,
        oldImageName,
        birthday,
        totalMark,
        education,
        currentSituation,
        levelOfPreparation,
        englishLevel,
        status,
        courseId,
        work,
        display,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.add1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for change current task.
     * @param {number} taskId id for the new current task for the student
     * @param {number} studentId student\&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeCurrentTask(
      taskId: number,
      studentId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.changeCurrentTask(
          taskId,
          studentId,
          options
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.changeCurrentTask']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for delete some student by id
     * @param {number} id ID by which the student is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteById1(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById1(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.deleteById1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for update some student.
     * @param {number} id id by which the object will be updated
     * @param {string} email
     * @param {string} [newPassword]
     * @param {string} [name]
     * @param {string} [lastName]
     * @param {string} [middleName]
     * @param {boolean} [isVideoReview]
     * @param {string} [telegram]
     * @param {string} [telephone]
     * @param {File} [image]
     * @param {string} [oldImageName]
     * @param {string} [birthday]
     * @param {number} [totalMark]
     * @param {Array<string>} [education]
     * @param {Edit2CurrentSituationEnum} [currentSituation]
     * @param {Edit2LevelOfPreparationEnum} [levelOfPreparation]
     * @param {Edit2EnglishLevelEnum} [englishLevel]
     * @param {Edit2StatusEnum} [status]
     * @param {number} [courseId]
     * @param {string} [work]
     * @param {boolean} [display]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async edit2(
      id: number,
      email: string,
      newPassword?: string,
      name?: string,
      lastName?: string,
      middleName?: string,
      isVideoReview?: boolean,
      telegram?: string,
      telephone?: string,
      image?: File,
      oldImageName?: string,
      birthday?: string,
      totalMark?: number,
      education?: Array<string>,
      currentSituation?: Edit2CurrentSituationEnum,
      levelOfPreparation?: Edit2LevelOfPreparationEnum,
      englishLevel?: Edit2EnglishLevelEnum,
      status?: Edit2StatusEnum,
      courseId?: number,
      work?: string,
      display?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.edit2(
        id,
        email,
        newPassword,
        name,
        lastName,
        middleName,
        isVideoReview,
        telegram,
        telephone,
        image,
        oldImageName,
        birthday,
        totalMark,
        education,
        currentSituation,
        levelOfPreparation,
        englishLevel,
        status,
        courseId,
        work,
        display,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.edit2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all students.
     * @param {StudentDtoForFilter} studentDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll1(
      studentDtoForFilter: StudentDtoForFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageStudentDtoForView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll1(
        studentDtoForFilter,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.getAll1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all student\'s tasks by student id.
     * @param {number} studentId ID by which the student\&#39;s tasks are being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllStudentTasks(
      studentId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentTasksDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllStudentTasks(studentId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.getAllStudentTasks']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting student by id for edit page
     * @param {number} id ID by which the student is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdForEdit1(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StudentDtoForAdd>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdForEdit1(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.getByIdForEdit1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting student by id for information card
     * @param {number} id ID by which the student is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdForView1(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StudentDtoForCard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdForView1(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.getByIdForView1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for update current task.
     * @param {StudentTasksDto} studentTasksDto Dto for update current student\&#39;s task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCurrentTask(
      studentTasksDto: StudentTasksDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateCurrentTask(
          studentTasksDto,
          options
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StudentControllerApi.updateCurrentTask']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * StudentControllerApi - factory interface
 * @export
 */
export const StudentControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StudentControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for add some student.
     * @param {StudentControllerApiAdd1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add1(
      requestParameters: StudentControllerApiAdd1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .add1(
          requestParameters.email,
          requestParameters.name,
          requestParameters.lastName,
          requestParameters.middleName,
          requestParameters.isVideoReview,
          requestParameters.telegram,
          requestParameters.telephone,
          requestParameters.image,
          requestParameters.oldImageName,
          requestParameters.birthday,
          requestParameters.totalMark,
          requestParameters.education,
          requestParameters.currentSituation,
          requestParameters.levelOfPreparation,
          requestParameters.englishLevel,
          requestParameters.status,
          requestParameters.courseId,
          requestParameters.work,
          requestParameters.display,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for change current task.
     * @param {StudentControllerApiChangeCurrentTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeCurrentTask(
      requestParameters: StudentControllerApiChangeCurrentTaskRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .changeCurrentTask(
          requestParameters.taskId,
          requestParameters.studentId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for delete some student by id
     * @param {StudentControllerApiDeleteById1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById1(
      requestParameters: StudentControllerApiDeleteById1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .deleteById1(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for update some student.
     * @param {StudentControllerApiEdit2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit2(
      requestParameters: StudentControllerApiEdit2Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .edit2(
          requestParameters.id,
          requestParameters.email,
          requestParameters.newPassword,
          requestParameters.name,
          requestParameters.lastName,
          requestParameters.middleName,
          requestParameters.isVideoReview,
          requestParameters.telegram,
          requestParameters.telephone,
          requestParameters.image,
          requestParameters.oldImageName,
          requestParameters.birthday,
          requestParameters.totalMark,
          requestParameters.education,
          requestParameters.currentSituation,
          requestParameters.levelOfPreparation,
          requestParameters.englishLevel,
          requestParameters.status,
          requestParameters.courseId,
          requestParameters.work,
          requestParameters.display,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all students.
     * @param {StudentControllerApiGetAll1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll1(
      requestParameters: StudentControllerApiGetAll1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageStudentDtoForView> {
      return localVarFp
        .getAll1(requestParameters.studentDtoForFilter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all student\'s tasks by student id.
     * @param {StudentControllerApiGetAllStudentTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllStudentTasks(
      requestParameters: StudentControllerApiGetAllStudentTasksRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentTasksDto>> {
      return localVarFp
        .getAllStudentTasks(requestParameters.studentId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting student by id for edit page
     * @param {StudentControllerApiGetByIdForEdit1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForEdit1(
      requestParameters: StudentControllerApiGetByIdForEdit1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentDtoForAdd> {
      return localVarFp
        .getByIdForEdit1(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting student by id for information card
     * @param {StudentControllerApiGetByIdForView1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForView1(
      requestParameters: StudentControllerApiGetByIdForView1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentDtoForCard> {
      return localVarFp
        .getByIdForView1(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for update current task.
     * @param {StudentControllerApiUpdateCurrentTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentTask(
      requestParameters: StudentControllerApiUpdateCurrentTaskRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .updateCurrentTask(requestParameters.studentTasksDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for add1 operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiAdd1Request
 */
export interface StudentControllerApiAdd1Request {
  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly email: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly name?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly lastName?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly middleName?: string

  /**
   *
   * @type {boolean}
   * @memberof StudentControllerApiAdd1
   */
  readonly isVideoReview?: boolean

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly telegram?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly telephone?: string

  /**
   *
   * @type {File}
   * @memberof StudentControllerApiAdd1
   */
  readonly image?: File

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly oldImageName?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly birthday?: string

  /**
   *
   * @type {number}
   * @memberof StudentControllerApiAdd1
   */
  readonly totalMark?: number

  /**
   *
   * @type {Array<string>}
   * @memberof StudentControllerApiAdd1
   */
  readonly education?: Array<string>

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly currentSituation?: Add1CurrentSituationEnum

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly levelOfPreparation?: Add1LevelOfPreparationEnum

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly englishLevel?: Add1EnglishLevelEnum

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly status?: Add1StatusEnum

  /**
   *
   * @type {number}
   * @memberof StudentControllerApiAdd1
   */
  readonly courseId?: number

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiAdd1
   */
  readonly work?: string

  /**
   *
   * @type {boolean}
   * @memberof StudentControllerApiAdd1
   */
  readonly display?: boolean
}

/**
 * Request parameters for changeCurrentTask operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiChangeCurrentTaskRequest
 */
export interface StudentControllerApiChangeCurrentTaskRequest {
  /**
   * id for the new current task for the student
   * @type {number}
   * @memberof StudentControllerApiChangeCurrentTask
   */
  readonly taskId: number

  /**
   * student\&#39;s id
   * @type {number}
   * @memberof StudentControllerApiChangeCurrentTask
   */
  readonly studentId: number
}

/**
 * Request parameters for deleteById1 operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiDeleteById1Request
 */
export interface StudentControllerApiDeleteById1Request {
  /**
   * ID by which the student is being deleted
   * @type {number}
   * @memberof StudentControllerApiDeleteById1
   */
  readonly id: number
}

/**
 * Request parameters for edit2 operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiEdit2Request
 */
export interface StudentControllerApiEdit2Request {
  /**
   * id by which the object will be updated
   * @type {number}
   * @memberof StudentControllerApiEdit2
   */
  readonly id: number

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly email: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly newPassword?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly name?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly lastName?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly middleName?: string

  /**
   *
   * @type {boolean}
   * @memberof StudentControllerApiEdit2
   */
  readonly isVideoReview?: boolean

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly telegram?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly telephone?: string

  /**
   *
   * @type {File}
   * @memberof StudentControllerApiEdit2
   */
  readonly image?: File

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly oldImageName?: string

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly birthday?: string

  /**
   *
   * @type {number}
   * @memberof StudentControllerApiEdit2
   */
  readonly totalMark?: number

  /**
   *
   * @type {Array<string>}
   * @memberof StudentControllerApiEdit2
   */
  readonly education?: Array<string>

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly currentSituation?: Edit2CurrentSituationEnum

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly levelOfPreparation?: Edit2LevelOfPreparationEnum

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly englishLevel?: Edit2EnglishLevelEnum

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly status?: Edit2StatusEnum

  /**
   *
   * @type {number}
   * @memberof StudentControllerApiEdit2
   */
  readonly courseId?: number

  /**
   *
   * @type {string}
   * @memberof StudentControllerApiEdit2
   */
  readonly work?: string

  /**
   *
   * @type {boolean}
   * @memberof StudentControllerApiEdit2
   */
  readonly display?: boolean
}

/**
 * Request parameters for getAll1 operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiGetAll1Request
 */
export interface StudentControllerApiGetAll1Request {
  /**
   * DTO for filter date. This DTO also has date for pagination
   * @type {StudentDtoForFilter}
   * @memberof StudentControllerApiGetAll1
   */
  readonly studentDtoForFilter: StudentDtoForFilter
}

/**
 * Request parameters for getAllStudentTasks operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiGetAllStudentTasksRequest
 */
export interface StudentControllerApiGetAllStudentTasksRequest {
  /**
   * ID by which the student\&#39;s tasks are being searched
   * @type {number}
   * @memberof StudentControllerApiGetAllStudentTasks
   */
  readonly studentId: number
}

/**
 * Request parameters for getByIdForEdit1 operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiGetByIdForEdit1Request
 */
export interface StudentControllerApiGetByIdForEdit1Request {
  /**
   * ID by which the student is being searched
   * @type {number}
   * @memberof StudentControllerApiGetByIdForEdit1
   */
  readonly id: number
}

/**
 * Request parameters for getByIdForView1 operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiGetByIdForView1Request
 */
export interface StudentControllerApiGetByIdForView1Request {
  /**
   * ID by which the student is being searched
   * @type {number}
   * @memberof StudentControllerApiGetByIdForView1
   */
  readonly id: number
}

/**
 * Request parameters for updateCurrentTask operation in StudentControllerApi.
 * @export
 * @interface StudentControllerApiUpdateCurrentTaskRequest
 */
export interface StudentControllerApiUpdateCurrentTaskRequest {
  /**
   * Dto for update current student\&#39;s task
   * @type {StudentTasksDto}
   * @memberof StudentControllerApiUpdateCurrentTask
   */
  readonly studentTasksDto: StudentTasksDto
}

/**
 * StudentControllerApi - object-oriented interface
 * @export
 * @class StudentControllerApi
 * @extends {BaseAPI}
 */
export class StudentControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for add some student.
   * @param {StudentControllerApiAdd1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public add1(
    requestParameters: StudentControllerApiAdd1Request,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .add1(
        requestParameters.email,
        requestParameters.name,
        requestParameters.lastName,
        requestParameters.middleName,
        requestParameters.isVideoReview,
        requestParameters.telegram,
        requestParameters.telephone,
        requestParameters.image,
        requestParameters.oldImageName,
        requestParameters.birthday,
        requestParameters.totalMark,
        requestParameters.education,
        requestParameters.currentSituation,
        requestParameters.levelOfPreparation,
        requestParameters.englishLevel,
        requestParameters.status,
        requestParameters.courseId,
        requestParameters.work,
        requestParameters.display,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for change current task.
   * @param {StudentControllerApiChangeCurrentTaskRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public changeCurrentTask(
    requestParameters: StudentControllerApiChangeCurrentTaskRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .changeCurrentTask(
        requestParameters.taskId,
        requestParameters.studentId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for delete some student by id
   * @param {StudentControllerApiDeleteById1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public deleteById1(
    requestParameters: StudentControllerApiDeleteById1Request,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .deleteById1(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for update some student.
   * @param {StudentControllerApiEdit2Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public edit2(
    requestParameters: StudentControllerApiEdit2Request,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .edit2(
        requestParameters.id,
        requestParameters.email,
        requestParameters.newPassword,
        requestParameters.name,
        requestParameters.lastName,
        requestParameters.middleName,
        requestParameters.isVideoReview,
        requestParameters.telegram,
        requestParameters.telephone,
        requestParameters.image,
        requestParameters.oldImageName,
        requestParameters.birthday,
        requestParameters.totalMark,
        requestParameters.education,
        requestParameters.currentSituation,
        requestParameters.levelOfPreparation,
        requestParameters.englishLevel,
        requestParameters.status,
        requestParameters.courseId,
        requestParameters.work,
        requestParameters.display,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all students.
   * @param {StudentControllerApiGetAll1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public getAll1(
    requestParameters: StudentControllerApiGetAll1Request,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .getAll1(requestParameters.studentDtoForFilter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all student\'s tasks by student id.
   * @param {StudentControllerApiGetAllStudentTasksRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public getAllStudentTasks(
    requestParameters: StudentControllerApiGetAllStudentTasksRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .getAllStudentTasks(requestParameters.studentId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting student by id for edit page
   * @param {StudentControllerApiGetByIdForEdit1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public getByIdForEdit1(
    requestParameters: StudentControllerApiGetByIdForEdit1Request,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .getByIdForEdit1(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting student by id for information card
   * @param {StudentControllerApiGetByIdForView1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public getByIdForView1(
    requestParameters: StudentControllerApiGetByIdForView1Request,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .getByIdForView1(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for update current task.
   * @param {StudentControllerApiUpdateCurrentTaskRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StudentControllerApi
   */
  public updateCurrentTask(
    requestParameters: StudentControllerApiUpdateCurrentTaskRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StudentControllerApiFp(this.configuration)
      .updateCurrentTask(requestParameters.studentTasksDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const Add1CurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const
export type Add1CurrentSituationEnum =
  (typeof Add1CurrentSituationEnum)[keyof typeof Add1CurrentSituationEnum]
/**
 * @export
 */
export const Add1LevelOfPreparationEnum = {
  NoSkills: 'NO_SKILLS',
  BadSkills: 'BAD_SKILLS',
  GoodSkills: 'GOOD_SKILLS',
  Ready: 'READY',
} as const
export type Add1LevelOfPreparationEnum =
  (typeof Add1LevelOfPreparationEnum)[keyof typeof Add1LevelOfPreparationEnum]
/**
 * @export
 */
export const Add1EnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const
export type Add1EnglishLevelEnum =
  (typeof Add1EnglishLevelEnum)[keyof typeof Add1EnglishLevelEnum]
/**
 * @export
 */
export const Add1StatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const
export type Add1StatusEnum =
  (typeof Add1StatusEnum)[keyof typeof Add1StatusEnum]
/**
 * @export
 */
export const Edit2CurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const
export type Edit2CurrentSituationEnum =
  (typeof Edit2CurrentSituationEnum)[keyof typeof Edit2CurrentSituationEnum]
/**
 * @export
 */
export const Edit2LevelOfPreparationEnum = {
  NoSkills: 'NO_SKILLS',
  BadSkills: 'BAD_SKILLS',
  GoodSkills: 'GOOD_SKILLS',
  Ready: 'READY',
} as const
export type Edit2LevelOfPreparationEnum =
  (typeof Edit2LevelOfPreparationEnum)[keyof typeof Edit2LevelOfPreparationEnum]
/**
 * @export
 */
export const Edit2EnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const
export type Edit2EnglishLevelEnum =
  (typeof Edit2EnglishLevelEnum)[keyof typeof Edit2EnglishLevelEnum]
/**
 * @export
 */
export const Edit2StatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const
export type Edit2StatusEnum =
  (typeof Edit2StatusEnum)[keyof typeof Edit2StatusEnum]

/**
 * TaskControllerApi - axios parameter creator
 * @export
 */
export const TaskControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for add some task.
     * @param {TaskDtoForAdd} taskDtoForAdd Dto for add task\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add: async (
      taskDtoForAdd: TaskDtoForAdd,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskDtoForAdd' is not null or undefined
      assertParamExists('add', 'taskDtoForAdd', taskDtoForAdd)
      const localVarPath = `/api/v1/task/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskDtoForAdd,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for delete task by id
     * @param {number} id ID by which the task is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteById', 'id', id)
      const localVarPath = `/api/v1/task/deleteById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for update some task.
     * @param {number} id id by which the object will be updated
     * @param {TaskDtoForAdd} taskDtoForAdd Dto for update task\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit1: async (
      id: number,
      taskDtoForAdd: TaskDtoForAdd,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('edit1', 'id', id)
      // verify required parameter 'taskDtoForAdd' is not null or undefined
      assertParamExists('edit1', 'taskDtoForAdd', taskDtoForAdd)
      const localVarPath = `/api/v1/task/edit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskDtoForAdd,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for generate page by task id
     * @param {number} id Task\&#39;s Id by which the page is being generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePage: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('generatePage', 'id', id)
      const localVarPath = `/api/v1/task/page`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting all tasks.
     * @param {TaskDtoForFilter} taskDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll: async (
      taskDtoForFilter: TaskDtoForFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskDtoForFilter' is not null or undefined
      assertParamExists('getAll', 'taskDtoForFilter', taskDtoForFilter)
      const localVarPath = `/api/v1/task/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (taskDtoForFilter !== undefined) {
        for (const [key, value] of Object.entries(taskDtoForFilter)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting task by id for edit page
     * @param {number} id ID by which the task is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForEdit: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdForEdit', 'id', id)
      const localVarPath = `/api/v1/task/getByIdForEdit`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting task by id for information card
     * @param {number} id ID by which the task is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForView: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getByIdForView', 'id', id)
      const localVarPath = `/api/v1/task/getByIdForView`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TaskControllerApi - functional programming interface
 * @export
 */
export const TaskControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TaskControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for add some task.
     * @param {TaskDtoForAdd} taskDtoForAdd Dto for add task\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add(
      taskDtoForAdd: TaskDtoForAdd,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.add(
        taskDtoForAdd,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.add']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for delete task by id
     * @param {number} id ID by which the task is being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteById(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.deleteById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for update some task.
     * @param {number} id id by which the object will be updated
     * @param {TaskDtoForAdd} taskDtoForAdd Dto for update task\&#39;s data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async edit1(
      id: number,
      taskDtoForAdd: TaskDtoForAdd,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.edit1(
        id,
        taskDtoForAdd,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.edit1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for generate page by task id
     * @param {number} id Task\&#39;s Id by which the page is being generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generatePage(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generatePage(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.generatePage']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting all tasks.
     * @param {TaskDtoForFilter} taskDtoForFilter DTO for filter date. This DTO also has date for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll(
      taskDtoForFilter: TaskDtoForFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageTaskDtoForView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(
        taskDtoForFilter,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.getAll']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting task by id for edit page
     * @param {number} id ID by which the task is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdForEdit(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDtoForAdd>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdForEdit(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.getByIdForEdit']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting task by id for information card
     * @param {number} id ID by which the task is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByIdForView(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDtoForCard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByIdForView(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.getByIdForView']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * TaskControllerApi - factory interface
 * @export
 */
export const TaskControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TaskControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for add some task.
     * @param {TaskControllerApiAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add(
      requestParameters: TaskControllerApiAddRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .add(requestParameters.taskDtoForAdd, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for delete task by id
     * @param {TaskControllerApiDeleteByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteById(
      requestParameters: TaskControllerApiDeleteByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .deleteById(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for update some task.
     * @param {TaskControllerApiEdit1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit1(
      requestParameters: TaskControllerApiEdit1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .edit1(requestParameters.id, requestParameters.taskDtoForAdd, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for generate page by task id
     * @param {TaskControllerApiGeneratePageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePage(
      requestParameters: TaskControllerApiGeneratePageRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .generatePage(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting all tasks.
     * @param {TaskControllerApiGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      requestParameters: TaskControllerApiGetAllRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageTaskDtoForView> {
      return localVarFp
        .getAll(requestParameters.taskDtoForFilter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting task by id for edit page
     * @param {TaskControllerApiGetByIdForEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForEdit(
      requestParameters: TaskControllerApiGetByIdForEditRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TaskDtoForAdd> {
      return localVarFp
        .getByIdForEdit(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting task by id for information card
     * @param {TaskControllerApiGetByIdForViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByIdForView(
      requestParameters: TaskControllerApiGetByIdForViewRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TaskDtoForCard> {
      return localVarFp
        .getByIdForView(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for add operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiAddRequest
 */
export interface TaskControllerApiAddRequest {
  /**
   * Dto for add task\&#39;s data.
   * @type {TaskDtoForAdd}
   * @memberof TaskControllerApiAdd
   */
  readonly taskDtoForAdd: TaskDtoForAdd
}

/**
 * Request parameters for deleteById operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiDeleteByIdRequest
 */
export interface TaskControllerApiDeleteByIdRequest {
  /**
   * ID by which the task is being deleted
   * @type {number}
   * @memberof TaskControllerApiDeleteById
   */
  readonly id: number
}

/**
 * Request parameters for edit1 operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiEdit1Request
 */
export interface TaskControllerApiEdit1Request {
  /**
   * id by which the object will be updated
   * @type {number}
   * @memberof TaskControllerApiEdit1
   */
  readonly id: number

  /**
   * Dto for update task\&#39;s data.
   * @type {TaskDtoForAdd}
   * @memberof TaskControllerApiEdit1
   */
  readonly taskDtoForAdd: TaskDtoForAdd
}

/**
 * Request parameters for generatePage operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiGeneratePageRequest
 */
export interface TaskControllerApiGeneratePageRequest {
  /**
   * Task\&#39;s Id by which the page is being generated
   * @type {number}
   * @memberof TaskControllerApiGeneratePage
   */
  readonly id: number
}

/**
 * Request parameters for getAll operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiGetAllRequest
 */
export interface TaskControllerApiGetAllRequest {
  /**
   * DTO for filter date. This DTO also has date for pagination
   * @type {TaskDtoForFilter}
   * @memberof TaskControllerApiGetAll
   */
  readonly taskDtoForFilter: TaskDtoForFilter
}

/**
 * Request parameters for getByIdForEdit operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiGetByIdForEditRequest
 */
export interface TaskControllerApiGetByIdForEditRequest {
  /**
   * ID by which the task is being searched
   * @type {number}
   * @memberof TaskControllerApiGetByIdForEdit
   */
  readonly id: number
}

/**
 * Request parameters for getByIdForView operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiGetByIdForViewRequest
 */
export interface TaskControllerApiGetByIdForViewRequest {
  /**
   * ID by which the task is being searched
   * @type {number}
   * @memberof TaskControllerApiGetByIdForView
   */
  readonly id: number
}

/**
 * TaskControllerApi - object-oriented interface
 * @export
 * @class TaskControllerApi
 * @extends {BaseAPI}
 */
export class TaskControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for add some task.
   * @param {TaskControllerApiAddRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public add(
    requestParameters: TaskControllerApiAddRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .add(requestParameters.taskDtoForAdd, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for delete task by id
   * @param {TaskControllerApiDeleteByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public deleteById(
    requestParameters: TaskControllerApiDeleteByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .deleteById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for update some task.
   * @param {TaskControllerApiEdit1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public edit1(
    requestParameters: TaskControllerApiEdit1Request,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .edit1(requestParameters.id, requestParameters.taskDtoForAdd, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for generate page by task id
   * @param {TaskControllerApiGeneratePageRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public generatePage(
    requestParameters: TaskControllerApiGeneratePageRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .generatePage(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting all tasks.
   * @param {TaskControllerApiGetAllRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public getAll(
    requestParameters: TaskControllerApiGetAllRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .getAll(requestParameters.taskDtoForFilter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting task by id for edit page
   * @param {TaskControllerApiGetByIdForEditRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public getByIdForEdit(
    requestParameters: TaskControllerApiGetByIdForEditRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .getByIdForEdit(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting task by id for information card
   * @param {TaskControllerApiGetByIdForViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public getByIdForView(
    requestParameters: TaskControllerApiGetByIdForViewRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .getByIdForView(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
