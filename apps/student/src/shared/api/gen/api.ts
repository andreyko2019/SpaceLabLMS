/* tslint:disable */
/* eslint-disable */
/**
 * Spacelab Learning App For Students
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface Contact
 */
export interface Contact {
  /**
   *
   * @type {number}
   * @memberof Contact
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'lastName'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'middleName'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  'email'?: string
  /**
   *
   * @type {boolean}
   * @memberof Contact
   */
  'isStudent'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Contact
   */
  'display'?: boolean
}
/**
 *
 * @export
 * @interface Course
 */
export interface Course {
  /**
   *
   * @type {number}
   * @memberof Course
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Course
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Course
   */
  'status'?: CourseStatusEnum
  /**
   *
   * @type {Array<Literature>}
   * @memberof Course
   */
  'literature'?: Array<Literature>
  /**
   *
   * @type {Array<Task>}
   * @memberof Course
   */
  'tasks'?: Array<Task>
  /**
   *
   * @type {Array<Student>}
   * @memberof Course
   */
  'students'?: Array<Student>
  /**
   *
   * @type {Manager}
   * @memberof Course
   */
  'manager'?: Manager
  /**
   *
   * @type {Manager}
   * @memberof Course
   */
  'mentor'?: Manager
}

export const CourseStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Recruiting: 'RECRUITING',
} as const

export type CourseStatusEnum =
  (typeof CourseStatusEnum)[keyof typeof CourseStatusEnum]

/**
 *
 * @export
 * @interface CourseDtoView
 */
export interface CourseDtoView {
  /**
   *
   * @type {number}
   * @memberof CourseDtoView
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof CourseDtoView
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof CourseDtoView
   */
  'status'?: CourseDtoViewStatusEnum
  /**
   *
   * @type {Array<Student>}
   * @memberof CourseDtoView
   */
  'students'?: Array<Student>
  /**
   *
   * @type {Manager}
   * @memberof CourseDtoView
   */
  'manager'?: Manager
  /**
   *
   * @type {Manager}
   * @memberof CourseDtoView
   */
  'mentor'?: Manager
}

export const CourseDtoViewStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Recruiting: 'RECRUITING',
} as const

export type CourseDtoViewStatusEnum =
  (typeof CourseDtoViewStatusEnum)[keyof typeof CourseDtoViewStatusEnum]

/**
 *
 * @export
 * @interface IntegerResponseEntity200Response
 */
export interface IntegerResponseEntity200Response {
  /**
   *
   * @type {boolean}
   * @memberof IntegerResponseEntity200Response
   */
  'parallel'?: boolean
}
/**
 *
 * @export
 * @interface JwtRequest
 */
export interface JwtRequest {
  /**
   * email
   * @type {string}
   * @memberof JwtRequest
   */
  'username'?: string
  /**
   * password
   * @type {string}
   * @memberof JwtRequest
   */
  'password'?: string
}
/**
 *
 * @export
 * @interface JwtResponse
 */
export interface JwtResponse {
  /**
   *
   * @type {string}
   * @memberof JwtResponse
   */
  'accessToken'?: string
  /**
   *
   * @type {string}
   * @memberof JwtResponse
   */
  'refreshToken'?: string
}
/**
 * LessonDtoView for the page where all lessons are displayed
 * @export
 * @interface LessonDtoView
 */
export interface LessonDtoView {
  /**
   *
   * @type {number}
   * @memberof LessonDtoView
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof LessonDtoView
   */
  'date'?: string
  /**
   *
   * @type {string}
   * @memberof LessonDtoView
   */
  'status'?: LessonDtoViewStatusEnum
  /**
   *
   * @type {string}
   * @memberof LessonDtoView
   */
  'link'?: string
  /**
   *
   * @type {LocalTime}
   * @memberof LessonDtoView
   */
  'durationLesson'?: LocalTime
  /**
   *
   * @type {CourseDtoView}
   * @memberof LessonDtoView
   */
  'course'?: CourseDtoView
  /**
   *
   * @type {ManagerDtoForView}
   * @memberof LessonDtoView
   */
  'mentor'?: ManagerDtoForView
}

export const LessonDtoViewStatusEnum = {
  Active: 'ACTIVE',
  Finished: 'FINISHED',
} as const

export type LessonDtoViewStatusEnum =
  (typeof LessonDtoViewStatusEnum)[keyof typeof LessonDtoViewStatusEnum]

/**
 *
 * @export
 * @interface Literature
 */
export interface Literature {
  /**
   *
   * @type {number}
   * @memberof Literature
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Literature
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Literature
   */
  'linkForDownload'?: string
  /**
   *
   * @type {string}
   * @memberof Literature
   */
  'typeLiterature'?: LiteratureTypeLiteratureEnum
  /**
   *
   * @type {Array<string>}
   * @memberof Literature
   */
  'keyWords'?: Array<string>
}

export const LiteratureTypeLiteratureEnum = {
  Book: 'BOOK',
  Link: 'LINK',
} as const

export type LiteratureTypeLiteratureEnum =
  (typeof LiteratureTypeLiteratureEnum)[keyof typeof LiteratureTypeLiteratureEnum]

/**
 *
 * @export
 * @interface LiteratureDtoForView
 */
export interface LiteratureDtoForView {
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForView
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForView
   */
  'linkForDownload'?: string
  /**
   *
   * @type {string}
   * @memberof LiteratureDtoForView
   */
  'typeLiterature'?: LiteratureDtoForViewTypeLiteratureEnum
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof LiteratureDtoForView
   */
  'course'?: { [key: string]: string }
  /**
   *
   * @type {Array<string>}
   * @memberof LiteratureDtoForView
   */
  'keyWords'?: Array<string>
}

export const LiteratureDtoForViewTypeLiteratureEnum = {
  Book: 'BOOK',
  Link: 'LINK',
} as const

export type LiteratureDtoForViewTypeLiteratureEnum =
  (typeof LiteratureDtoForViewTypeLiteratureEnum)[keyof typeof LiteratureDtoForViewTypeLiteratureEnum]

/**
 *
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  'hour'?: number
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  'minute'?: number
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  'second'?: number
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  'nano'?: number
}
/**
 *
 * @export
 * @interface Manager
 */
export interface Manager {
  /**
   *
   * @type {number}
   * @memberof Manager
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  'email'?: string
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  'image'?: string
  /**
   *
   * @type {number}
   * @memberof Manager
   */
  'pageSize'?: number
  /**
   *
   * @type {boolean}
   * @memberof Manager
   */
  'themeIsDark'?: boolean
  /**
   *
   * @type {Contact}
   * @memberof Manager
   */
  'contact'?: Contact
  /**
   *
   * @type {string}
   * @memberof Manager
   */
  'status'?: ManagerStatusEnum
  /**
   *
   * @type {Array<Course>}
   * @memberof Manager
   */
  'courses'?: Array<Course>
}

export const ManagerStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const

export type ManagerStatusEnum =
  (typeof ManagerStatusEnum)[keyof typeof ManagerStatusEnum]

/**
 * ManagerDto for the page where all managers are displayed
 * @export
 * @interface ManagerDtoForView
 */
export interface ManagerDtoForView {
  /**
   *
   * @type {number}
   * @memberof ManagerDtoForView
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForView
   */
  'fullName'?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ManagerDtoForView
   */
  'courses'?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForView
   */
  'role'?: string
  /**
   *
   * @type {string}
   * @memberof ManagerDtoForView
   */
  'status'?: ManagerDtoForViewStatusEnum
}

export const ManagerDtoForViewStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
} as const

export type ManagerDtoForViewStatusEnum =
  (typeof ManagerDtoForViewStatusEnum)[keyof typeof ManagerDtoForViewStatusEnum]

/**
 *
 * @export
 * @interface MessageStudentClick
 */
export interface MessageStudentClick {
  /**
   *
   * @type {number}
   * @memberof MessageStudentClick
   */
  'studentId'?: number
  /**
   *
   * @type {number}
   * @memberof MessageStudentClick
   */
  'lessonId'?: number
}
/**
 *
 * @export
 * @interface PageLessonDtoView
 */
export interface PageLessonDtoView {
  /**
   *
   * @type {number}
   * @memberof PageLessonDtoView
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageLessonDtoView
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageLessonDtoView
   */
  'size'?: number
  /**
   *
   * @type {Array<LessonDtoView>}
   * @memberof PageLessonDtoView
   */
  'content'?: Array<LessonDtoView>
  /**
   *
   * @type {number}
   * @memberof PageLessonDtoView
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageLessonDtoView
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageLessonDtoView
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageLessonDtoView
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageLessonDtoView
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageLessonDtoView
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageLessonDtoView
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageLiteratureDtoForView
 */
export interface PageLiteratureDtoForView {
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'size'?: number
  /**
   *
   * @type {Array<LiteratureDtoForView>}
   * @memberof PageLiteratureDtoForView
   */
  'content'?: Array<LiteratureDtoForView>
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageLiteratureDtoForView
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageLiteratureDtoForView
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageLiteratureDtoForView
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageLiteratureDtoForView
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageLiteratureDtoForView
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageLiteratureDtoForView
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageStudentTask
 */
export interface PageStudentTask {
  /**
   *
   * @type {number}
   * @memberof PageStudentTask
   */
  'totalElements'?: number
  /**
   *
   * @type {number}
   * @memberof PageStudentTask
   */
  'totalPages'?: number
  /**
   *
   * @type {number}
   * @memberof PageStudentTask
   */
  'size'?: number
  /**
   *
   * @type {Array<StudentTask>}
   * @memberof PageStudentTask
   */
  'content'?: Array<StudentTask>
  /**
   *
   * @type {number}
   * @memberof PageStudentTask
   */
  'number'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageStudentTask
   */
  'sort'?: SortObject
  /**
   *
   * @type {PageableObject}
   * @memberof PageStudentTask
   */
  'pageable'?: PageableObject
  /**
   *
   * @type {number}
   * @memberof PageStudentTask
   */
  'numberOfElements'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageStudentTask
   */
  'first'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageStudentTask
   */
  'last'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageStudentTask
   */
  'empty'?: boolean
}
/**
 *
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  'offset'?: number
  /**
   *
   * @type {SortObject}
   * @memberof PageableObject
   */
  'sort'?: SortObject
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  'pageNumber'?: number
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  'pageSize'?: number
  /**
   *
   * @type {boolean}
   * @memberof PageableObject
   */
  'paged'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof PageableObject
   */
  'unpaged'?: boolean
}
/**
 *
 * @export
 * @interface PersonalDataResponseForAdd
 */
export interface PersonalDataResponseForAdd {
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'lastName'?: string
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'middleName'?: string
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'telegram'?: string
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'telephone'?: string
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'email'?: string
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'work'?: string
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'image'?: string
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'birthday'?: string
  /**
   *
   * @type {Array<string>}
   * @memberof PersonalDataResponseForAdd
   */
  'education'?: Array<string>
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'englishLevel'?: PersonalDataResponseForAddEnglishLevelEnum
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PersonalDataResponseForAdd
   */
  'course'?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof PersonalDataResponseForAdd
   */
  'currentSituation'?: PersonalDataResponseForAddCurrentSituationEnum
}

export const PersonalDataResponseForAddEnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const

export type PersonalDataResponseForAddEnglishLevelEnum =
  (typeof PersonalDataResponseForAddEnglishLevelEnum)[keyof typeof PersonalDataResponseForAddEnglishLevelEnum]
export const PersonalDataResponseForAddCurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const

export type PersonalDataResponseForAddCurrentSituationEnum =
  (typeof PersonalDataResponseForAddCurrentSituationEnum)[keyof typeof PersonalDataResponseForAddCurrentSituationEnum]

/**
 *
 * @export
 * @interface SortObject
 */
export interface SortObject {
  /**
   *
   * @type {boolean}
   * @memberof SortObject
   */
  'empty'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof SortObject
   */
  'sorted'?: boolean
  /**
   *
   * @type {boolean}
   * @memberof SortObject
   */
  'unsorted'?: boolean
}
/**
 *
 * @export
 * @interface Student
 */
export interface Student {
  /**
   *
   * @type {number}
   * @memberof Student
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'email'?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'image'?: string
  /**
   *
   * @type {number}
   * @memberof Student
   */
  'pageSize'?: number
  /**
   *
   * @type {boolean}
   * @memberof Student
   */
  'themeIsDark'?: boolean
  /**
   *
   * @type {Contact}
   * @memberof Student
   */
  'contact'?: Contact
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'status'?: StudentStatusEnum
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'levelOfPreparation'?: StudentLevelOfPreparationEnum
  /**
   *
   * @type {boolean}
   * @memberof Student
   */
  'isVideoReview'?: boolean
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'birthday'?: string
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'work'?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Student
   */
  'education'?: Array<string>
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'englishLevel'?: StudentEnglishLevelEnum
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'currentSituation'?: StudentCurrentSituationEnum
  /**
   *
   * @type {number}
   * @memberof Student
   */
  'totalMark'?: number
  /**
   *
   * @type {string}
   * @memberof Student
   */
  'dateOfJoining'?: string
  /**
   *
   * @type {Course}
   * @memberof Student
   */
  'course'?: Course
}

export const StudentStatusEnum = {
  Active: 'ACTIVE',
  Blocked: 'BLOCKED',
  Expelled: 'EXPELLED',
} as const

export type StudentStatusEnum =
  (typeof StudentStatusEnum)[keyof typeof StudentStatusEnum]
export const StudentLevelOfPreparationEnum = {
  NoSkills: 'NO_SKILLS',
  BadSkills: 'BAD_SKILLS',
  GoodSkills: 'GOOD_SKILLS',
  Ready: 'READY',
} as const

export type StudentLevelOfPreparationEnum =
  (typeof StudentLevelOfPreparationEnum)[keyof typeof StudentLevelOfPreparationEnum]
export const StudentEnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const

export type StudentEnglishLevelEnum =
  (typeof StudentEnglishLevelEnum)[keyof typeof StudentEnglishLevelEnum]
export const StudentCurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const

export type StudentCurrentSituationEnum =
  (typeof StudentCurrentSituationEnum)[keyof typeof StudentCurrentSituationEnum]

/**
 *
 * @export
 * @interface StudentTask
 */
export interface StudentTask {
  /**
   *
   * @type {number}
   * @memberof StudentTask
   */
  'id'?: number
  /**
   *
   * @type {Task}
   * @memberof StudentTask
   */
  'task'?: Task
  /**
   *
   * @type {string}
   * @memberof StudentTask
   */
  'status'?: StudentTaskStatusEnum
  /**
   *
   * @type {string}
   * @memberof StudentTask
   */
  'comment'?: string
}

export const StudentTaskStatusEnum = {
  InProgress: 'IN_PROGRESS',
  Testing: 'TESTING',
  Done: 'DONE',
} as const

export type StudentTaskStatusEnum =
  (typeof StudentTaskStatusEnum)[keyof typeof StudentTaskStatusEnum]

/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   *
   * @type {number}
   * @memberof Task
   */
  'id'?: number
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'name'?: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'aim'?: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'description'?: string
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'level'?: TaskLevelEnum
  /**
   *
   * @type {string}
   * @memberof Task
   */
  'status'?: TaskStatusEnum
  /**
   *
   * @type {Course}
   * @memberof Task
   */
  'course'?: Course
  /**
   *
   * @type {Array<Task>}
   * @memberof Task
   */
  'subTasks'?: Array<Task>
}

export const TaskLevelEnum = {
  Easy: 'EASY',
  Middle: 'MIDDLE',
  Hard: 'HARD',
} as const

export type TaskLevelEnum = (typeof TaskLevelEnum)[keyof typeof TaskLevelEnum]
export const TaskStatusEnum = {
  Active: 'ACTIVE',
  NotActive: 'NOT_ACTIVE',
  BeingEdited: 'BEING_EDITED',
} as const

export type TaskStatusEnum =
  (typeof TaskStatusEnum)[keyof typeof TaskStatusEnum]

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Authorization user
     * @param {JwtRequest} jwtRequest Data for authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      jwtRequest: JwtRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jwtRequest' is not null or undefined
      assertParamExists('login', 'jwtRequest', jwtRequest)
      const localVarPath = `/api/v1/auth/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        jwtRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update the access token
     * @param {string} refreshToken Refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh: async (
      refreshToken: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshToken' is not null or undefined
      assertParamExists('refresh', 'refreshToken', refreshToken)
      const localVarPath = `/api/v1/auth/refresh`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (refreshToken != null) {
        localVarHeaderParameter['refreshToken'] = String(refreshToken)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Authorization user
     * @param {JwtRequest} jwtRequest Data for authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      jwtRequest: JwtRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        jwtRequest,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthControllerApi.login']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Update the access token
     * @param {string} refreshToken Refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refresh(
      refreshToken: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(
        refreshToken,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthControllerApi.refresh']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthControllerApiFp(configuration)
  return {
    /**
     *
     * @summary Authorization user
     * @param {AuthControllerApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      requestParameters: AuthControllerApiLoginRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<JwtResponse> {
      return localVarFp
        .login(requestParameters.jwtRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update the access token
     * @param {AuthControllerApiRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh(
      requestParameters: AuthControllerApiRefreshRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<JwtResponse> {
      return localVarFp
        .refresh(requestParameters.refreshToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for login operation in AuthControllerApi.
 * @export
 * @interface AuthControllerApiLoginRequest
 */
export interface AuthControllerApiLoginRequest {
  /**
   * Data for authorization
   * @type {JwtRequest}
   * @memberof AuthControllerApiLogin
   */
  readonly jwtRequest: JwtRequest
}

/**
 * Request parameters for refresh operation in AuthControllerApi.
 * @export
 * @interface AuthControllerApiRefreshRequest
 */
export interface AuthControllerApiRefreshRequest {
  /**
   * Refresh token
   * @type {string}
   * @memberof AuthControllerApiRefresh
   */
  readonly refreshToken: string
}

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
  /**
   *
   * @summary Authorization user
   * @param {AuthControllerApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public login(
    requestParameters: AuthControllerApiLoginRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthControllerApiFp(this.configuration)
      .login(requestParameters.jwtRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update the access token
   * @param {AuthControllerApiRefreshRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public refresh(
    requestParameters: AuthControllerApiRefreshRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthControllerApiFp(this.configuration)
      .refresh(requestParameters.refreshToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EnumControllerApi - axios parameter creator
 * @export
 */
export const EnumControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get all courses statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCourseStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/courseStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all current situations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCurrentSituations: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/currentSituations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all English levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEnglishLevels: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/englishLevels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all lesson statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLessonStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/lessonStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all task levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLevels: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/taskLevels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all literature types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLiteratureTypes: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/literatureTypes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all manager statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listManagerStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/managerStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPages: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/pages`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all preparation levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPreparationLevels: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/preparationLevels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStudentStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/studentStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all task for student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskForStudentStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/taskForStudentStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all task statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskStatuses: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/enum/taskStatuses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EnumControllerApi - functional programming interface
 * @export
 */
export const EnumControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EnumControllerApiAxiosParamCreator(configuration)
  return {
    /**
     * Get all courses statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCourseStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listCourseStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listCourseStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all current situations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCurrentSituations(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listCurrentSituations(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listCurrentSituations']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all English levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEnglishLevels(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listEnglishLevels(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listEnglishLevels']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all lesson statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLessonStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listLessonStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listLessonStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all task levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLevels(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listLevels(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listLevels']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all literature types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLiteratureTypes(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listLiteratureTypes(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listLiteratureTypes']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all manager statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listManagerStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listManagerStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listManagerStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPages(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPages(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listPages']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all preparation levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPreparationLevels(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listPreparationLevels(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listPreparationLevels']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listStudentStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listStudentStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listStudentStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all task for student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTaskForStudentStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTaskForStudentStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listTaskForStudentStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get all task statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTaskStatuses(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTaskStatuses(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['EnumControllerApi.listTaskStatuses']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * EnumControllerApi - factory interface
 * @export
 */
export const EnumControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EnumControllerApiFp(configuration)
  return {
    /**
     * Get all courses statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCourseStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listCourseStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all current situations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCurrentSituations(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listCurrentSituations(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all English levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEnglishLevels(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listEnglishLevels(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all lesson statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLessonStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listLessonStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all task levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLevels(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
      return localVarFp
        .listLevels(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all literature types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLiteratureTypes(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listLiteratureTypes(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all manager statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listManagerStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listManagerStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPages(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
      return localVarFp
        .listPages(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all preparation levels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPreparationLevels(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listPreparationLevels(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStudentStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listStudentStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all task for student statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskForStudentStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listTaskForStudentStatuses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all task statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskStatuses(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listTaskStatuses(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EnumControllerApi - object-oriented interface
 * @export
 * @class EnumControllerApi
 * @extends {BaseAPI}
 */
export class EnumControllerApi extends BaseAPI {
  /**
   * Get all courses statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listCourseStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listCourseStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all current situations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listCurrentSituations(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listCurrentSituations(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all English levels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listEnglishLevels(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listEnglishLevels(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all lesson statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listLessonStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listLessonStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all task levels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listLevels(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listLevels(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all literature types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listLiteratureTypes(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listLiteratureTypes(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all manager statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listManagerStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listManagerStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all pages
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listPages(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listPages(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all preparation levels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listPreparationLevels(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listPreparationLevels(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all student statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listStudentStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listStudentStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all task for student statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listTaskForStudentStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listTaskForStudentStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all task statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnumControllerApi
   */
  public listTaskStatuses(options?: RawAxiosRequestConfig) {
    return EnumControllerApiFp(this.configuration)
      .listTaskStatuses(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * LessonControllerApi - axios parameter creator
 * @export
 */
export const LessonControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for getting tasks.
     * @param {number} page Page for pagination
     * @param {number} size Number of elements for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllActive: async (
      page: number,
      size: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists('getAllActive', 'page', page)
      // verify required parameter 'size' is not null or undefined
      assertParamExists('getAllActive', 'size', size)
      const localVarPath = `/api/v1/lessons/getAllActive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting tasks.
     * @param {number} page Page for pagination
     * @param {number} size Number of elements for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFinished: async (
      page: number,
      size: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists('getAllFinished', 'page', page)
      // verify required parameter 'size' is not null or undefined
      assertParamExists('getAllFinished', 'size', size)
      const localVarPath = `/api/v1/lessons/getAllFinished`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LessonControllerApi - functional programming interface
 * @export
 */
export const LessonControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    LessonControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for getting tasks.
     * @param {number} page Page for pagination
     * @param {number} size Number of elements for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllActive(
      page: number,
      size: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageLessonDtoView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllActive(
        page,
        size,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LessonControllerApi.getAllActive']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting tasks.
     * @param {number} page Page for pagination
     * @param {number} size Number of elements for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllFinished(
      page: number,
      size: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageLessonDtoView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFinished(
        page,
        size,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LessonControllerApi.getAllFinished']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * LessonControllerApi - factory interface
 * @export
 */
export const LessonControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LessonControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for getting tasks.
     * @param {LessonControllerApiGetAllActiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllActive(
      requestParameters: LessonControllerApiGetAllActiveRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageLessonDtoView> {
      return localVarFp
        .getAllActive(requestParameters.page, requestParameters.size, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting tasks.
     * @param {LessonControllerApiGetAllFinishedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFinished(
      requestParameters: LessonControllerApiGetAllFinishedRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageLessonDtoView> {
      return localVarFp
        .getAllFinished(requestParameters.page, requestParameters.size, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for getAllActive operation in LessonControllerApi.
 * @export
 * @interface LessonControllerApiGetAllActiveRequest
 */
export interface LessonControllerApiGetAllActiveRequest {
  /**
   * Page for pagination
   * @type {number}
   * @memberof LessonControllerApiGetAllActive
   */
  readonly page: number

  /**
   * Number of elements for pagination
   * @type {number}
   * @memberof LessonControllerApiGetAllActive
   */
  readonly size: number
}

/**
 * Request parameters for getAllFinished operation in LessonControllerApi.
 * @export
 * @interface LessonControllerApiGetAllFinishedRequest
 */
export interface LessonControllerApiGetAllFinishedRequest {
  /**
   * Page for pagination
   * @type {number}
   * @memberof LessonControllerApiGetAllFinished
   */
  readonly page: number

  /**
   * Number of elements for pagination
   * @type {number}
   * @memberof LessonControllerApiGetAllFinished
   */
  readonly size: number
}

/**
 * LessonControllerApi - object-oriented interface
 * @export
 * @class LessonControllerApi
 * @extends {BaseAPI}
 */
export class LessonControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for getting tasks.
   * @param {LessonControllerApiGetAllActiveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonControllerApi
   */
  public getAllActive(
    requestParameters: LessonControllerApiGetAllActiveRequest,
    options?: RawAxiosRequestConfig
  ) {
    return LessonControllerApiFp(this.configuration)
      .getAllActive(requestParameters.page, requestParameters.size, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting tasks.
   * @param {LessonControllerApiGetAllFinishedRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LessonControllerApi
   */
  public getAllFinished(
    requestParameters: LessonControllerApiGetAllFinishedRequest,
    options?: RawAxiosRequestConfig
  ) {
    return LessonControllerApiFp(this.configuration)
      .getAllFinished(requestParameters.page, requestParameters.size, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * LiteratureControllerApi - axios parameter creator
 * @export
 */
export const LiteratureControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for getting Literatures.
     * @param {number} size Number of elements for pagination
     * @param {number} page Page for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll1: async (
      size: number,
      page: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'size' is not null or undefined
      assertParamExists('getAll1', 'size', size)
      // verify required parameter 'page' is not null or undefined
      assertParamExists('getAll1', 'page', page)
      const localVarPath = `/api/v1/literature/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LiteratureControllerApi - functional programming interface
 * @export
 */
export const LiteratureControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    LiteratureControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for getting Literatures.
     * @param {number} size Number of elements for pagination
     * @param {number} page Page for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll1(
      size: number,
      page: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageLiteratureDtoForView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll1(
        size,
        page,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LiteratureControllerApi.getAll1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * LiteratureControllerApi - factory interface
 * @export
 */
export const LiteratureControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LiteratureControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for getting Literatures.
     * @param {LiteratureControllerApiGetAll1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll1(
      requestParameters: LiteratureControllerApiGetAll1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageLiteratureDtoForView> {
      return localVarFp
        .getAll1(requestParameters.size, requestParameters.page, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for getAll1 operation in LiteratureControllerApi.
 * @export
 * @interface LiteratureControllerApiGetAll1Request
 */
export interface LiteratureControllerApiGetAll1Request {
  /**
   * Number of elements for pagination
   * @type {number}
   * @memberof LiteratureControllerApiGetAll1
   */
  readonly size: number

  /**
   * Page for pagination
   * @type {number}
   * @memberof LiteratureControllerApiGetAll1
   */
  readonly page: number
}

/**
 * LiteratureControllerApi - object-oriented interface
 * @export
 * @class LiteratureControllerApi
 * @extends {BaseAPI}
 */
export class LiteratureControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for getting Literatures.
   * @param {LiteratureControllerApiGetAll1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiteratureControllerApi
   */
  public getAll1(
    requestParameters: LiteratureControllerApiGetAll1Request,
    options?: RawAxiosRequestConfig
  ) {
    return LiteratureControllerApiFp(this.configuration)
      .getAll1(requestParameters.size, requestParameters.page, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PersonalAreaControllerApi - axios parameter creator
 * @export
 */
export const PersonalAreaControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for updating page size
     * @param {number} pageSize The number of pages that will be displayed for the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePageSize: async (
      pageSize: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pageSize' is not null or undefined
      assertParamExists('changePageSize', 'pageSize', pageSize)
      const localVarPath = `/api/v1/personalArea/changePageSize`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for updating theme
     * @param {boolean} theme If value is false theme is light, if value is true theme is dark
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeTheme: async (
      theme: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'theme' is not null or undefined
      assertParamExists('changeTheme', 'theme', theme)
      const localVarPath = `/api/v1/personalArea/changeTheme`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (theme !== undefined) {
        localVarQueryParameter['theme'] = theme
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for delete img and generate avatar with name and lastname.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/personalArea/deleteAvatar`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for edit personal data.
     * @param {string} name
     * @param {string} lastName
     * @param {string} middleName
     * @param {string} telegram
     * @param {string} telephone
     * @param {string} email
     * @param {string} birthday
     * @param {File} [newFile]
     * @param {string} [oldFile]
     * @param {string} [work]
     * @param {Array<string>} [education]
     * @param {EditPersonalDataEnglishLevelEnum} [englishLevel]
     * @param {EditPersonalDataCurrentSituationEnum} [currentSituation]
     * @param {string} [password]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPersonalData: async (
      name: string,
      lastName: string,
      middleName: string,
      telegram: string,
      telephone: string,
      email: string,
      birthday: string,
      newFile?: File,
      oldFile?: string,
      work?: string,
      education?: Array<string>,
      englishLevel?: EditPersonalDataEnglishLevelEnum,
      currentSituation?: EditPersonalDataCurrentSituationEnum,
      password?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('editPersonalData', 'name', name)
      // verify required parameter 'lastName' is not null or undefined
      assertParamExists('editPersonalData', 'lastName', lastName)
      // verify required parameter 'middleName' is not null or undefined
      assertParamExists('editPersonalData', 'middleName', middleName)
      // verify required parameter 'telegram' is not null or undefined
      assertParamExists('editPersonalData', 'telegram', telegram)
      // verify required parameter 'telephone' is not null or undefined
      assertParamExists('editPersonalData', 'telephone', telephone)
      // verify required parameter 'email' is not null or undefined
      assertParamExists('editPersonalData', 'email', email)
      // verify required parameter 'birthday' is not null or undefined
      assertParamExists('editPersonalData', 'birthday', birthday)
      const localVarPath = `/api/v1/personalArea/editPersonalData`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (name !== undefined) {
        localVarFormParams.append('name', name as any)
      }

      if (lastName !== undefined) {
        localVarFormParams.append('lastName', lastName as any)
      }

      if (middleName !== undefined) {
        localVarFormParams.append('middleName', middleName as any)
      }

      if (telegram !== undefined) {
        localVarFormParams.append('telegram', telegram as any)
      }

      if (telephone !== undefined) {
        localVarFormParams.append('telephone', telephone as any)
      }

      if (email !== undefined) {
        localVarFormParams.append('email', email as any)
      }

      if (newFile !== undefined) {
        localVarFormParams.append('newFile', newFile as any)
      }

      if (oldFile !== undefined) {
        localVarFormParams.append('oldFile', oldFile as any)
      }

      if (work !== undefined) {
        localVarFormParams.append('work', work as any)
      }

      if (birthday !== undefined) {
        localVarFormParams.append('birthday', birthday as any)
      }
      if (education) {
        localVarFormParams.append(
          'education',
          education.join(COLLECTION_FORMATS.csv)
        )
      }

      if (englishLevel !== undefined) {
        localVarFormParams.append('englishLevel', englishLevel as any)
      }

      if (currentSituation !== undefined) {
        localVarFormParams.append('currentSituation', currentSituation as any)
      }

      if (password !== undefined) {
        localVarFormParams.append('password', password as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageSize: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/personalArea/getPageSize`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting personal data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPersonalData: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/personalArea/getPersonalData`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTheme: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/personalArea/getTheme`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PersonalAreaControllerApi - functional programming interface
 * @export
 */
export const PersonalAreaControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    PersonalAreaControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for updating page size
     * @param {number} pageSize The number of pages that will be displayed for the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePageSize(
      pageSize: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePageSize(
        pageSize,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PersonalAreaControllerApi.changePageSize']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for updating theme
     * @param {boolean} theme If value is false theme is light, if value is true theme is dark
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeTheme(
      theme: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changeTheme(
        theme,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PersonalAreaControllerApi.changeTheme']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for delete img and generate avatar with name and lastname.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAvatar(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAvatar(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PersonalAreaControllerApi.deleteAvatar']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for edit personal data.
     * @param {string} name
     * @param {string} lastName
     * @param {string} middleName
     * @param {string} telegram
     * @param {string} telephone
     * @param {string} email
     * @param {string} birthday
     * @param {File} [newFile]
     * @param {string} [oldFile]
     * @param {string} [work]
     * @param {Array<string>} [education]
     * @param {EditPersonalDataEnglishLevelEnum} [englishLevel]
     * @param {EditPersonalDataCurrentSituationEnum} [currentSituation]
     * @param {string} [password]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editPersonalData(
      name: string,
      lastName: string,
      middleName: string,
      telegram: string,
      telephone: string,
      email: string,
      birthday: string,
      newFile?: File,
      oldFile?: string,
      work?: string,
      education?: Array<string>,
      englishLevel?: EditPersonalDataEnglishLevelEnum,
      currentSituation?: EditPersonalDataCurrentSituationEnum,
      password?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editPersonalData(
          name,
          lastName,
          middleName,
          telegram,
          telephone,
          email,
          birthday,
          newFile,
          oldFile,
          work,
          education,
          englishLevel,
          currentSituation,
          password,
          options
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PersonalAreaControllerApi.editPersonalData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageSize(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageSize(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PersonalAreaControllerApi.getPageSize']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting personal data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPersonalData(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PersonalDataResponseForAdd>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonalData(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PersonalAreaControllerApi.getPersonalData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTheme(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTheme(
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PersonalAreaControllerApi.getTheme']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PersonalAreaControllerApi - factory interface
 * @export
 */
export const PersonalAreaControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PersonalAreaControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for updating page size
     * @param {PersonalAreaControllerApiChangePageSizeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePageSize(
      requestParameters: PersonalAreaControllerApiChangePageSizeRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .changePageSize(requestParameters.pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for updating theme
     * @param {PersonalAreaControllerApiChangeThemeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeTheme(
      requestParameters: PersonalAreaControllerApiChangeThemeRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .changeTheme(requestParameters.theme, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for delete img and generate avatar with name and lastname.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .deleteAvatar(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for edit personal data.
     * @param {PersonalAreaControllerApiEditPersonalDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPersonalData(
      requestParameters: PersonalAreaControllerApiEditPersonalDataRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .editPersonalData(
          requestParameters.name,
          requestParameters.lastName,
          requestParameters.middleName,
          requestParameters.telegram,
          requestParameters.telephone,
          requestParameters.email,
          requestParameters.birthday,
          requestParameters.newFile,
          requestParameters.oldFile,
          requestParameters.work,
          requestParameters.education,
          requestParameters.englishLevel,
          requestParameters.currentSituation,
          requestParameters.password,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageSize(options?: RawAxiosRequestConfig): AxiosPromise<number> {
      return localVarFp
        .getPageSize(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting personal data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPersonalData(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PersonalDataResponseForAdd> {
      return localVarFp
        .getPersonalData(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTheme(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
      return localVarFp
        .getTheme(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for changePageSize operation in PersonalAreaControllerApi.
 * @export
 * @interface PersonalAreaControllerApiChangePageSizeRequest
 */
export interface PersonalAreaControllerApiChangePageSizeRequest {
  /**
   * The number of pages that will be displayed for the authorized user
   * @type {number}
   * @memberof PersonalAreaControllerApiChangePageSize
   */
  readonly pageSize: number
}

/**
 * Request parameters for changeTheme operation in PersonalAreaControllerApi.
 * @export
 * @interface PersonalAreaControllerApiChangeThemeRequest
 */
export interface PersonalAreaControllerApiChangeThemeRequest {
  /**
   * If value is false theme is light, if value is true theme is dark
   * @type {boolean}
   * @memberof PersonalAreaControllerApiChangeTheme
   */
  readonly theme: boolean
}

/**
 * Request parameters for editPersonalData operation in PersonalAreaControllerApi.
 * @export
 * @interface PersonalAreaControllerApiEditPersonalDataRequest
 */
export interface PersonalAreaControllerApiEditPersonalDataRequest {
  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly name: string

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly lastName: string

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly middleName: string

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly telegram: string

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly telephone: string

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly email: string

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly birthday: string

  /**
   *
   * @type {File}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly newFile?: File

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly oldFile?: string

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly work?: string

  /**
   *
   * @type {Array<string>}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly education?: Array<string>

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly englishLevel?: EditPersonalDataEnglishLevelEnum

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly currentSituation?: EditPersonalDataCurrentSituationEnum

  /**
   *
   * @type {string}
   * @memberof PersonalAreaControllerApiEditPersonalData
   */
  readonly password?: string
}

/**
 * PersonalAreaControllerApi - object-oriented interface
 * @export
 * @class PersonalAreaControllerApi
 * @extends {BaseAPI}
 */
export class PersonalAreaControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for updating page size
   * @param {PersonalAreaControllerApiChangePageSizeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonalAreaControllerApi
   */
  public changePageSize(
    requestParameters: PersonalAreaControllerApiChangePageSizeRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PersonalAreaControllerApiFp(this.configuration)
      .changePageSize(requestParameters.pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for updating theme
   * @param {PersonalAreaControllerApiChangeThemeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonalAreaControllerApi
   */
  public changeTheme(
    requestParameters: PersonalAreaControllerApiChangeThemeRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PersonalAreaControllerApiFp(this.configuration)
      .changeTheme(requestParameters.theme, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for delete img and generate avatar with name and lastname.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonalAreaControllerApi
   */
  public deleteAvatar(options?: RawAxiosRequestConfig) {
    return PersonalAreaControllerApiFp(this.configuration)
      .deleteAvatar(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for edit personal data.
   * @param {PersonalAreaControllerApiEditPersonalDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonalAreaControllerApi
   */
  public editPersonalData(
    requestParameters: PersonalAreaControllerApiEditPersonalDataRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PersonalAreaControllerApiFp(this.configuration)
      .editPersonalData(
        requestParameters.name,
        requestParameters.lastName,
        requestParameters.middleName,
        requestParameters.telegram,
        requestParameters.telephone,
        requestParameters.email,
        requestParameters.birthday,
        requestParameters.newFile,
        requestParameters.oldFile,
        requestParameters.work,
        requestParameters.education,
        requestParameters.englishLevel,
        requestParameters.currentSituation,
        requestParameters.password,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting page size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonalAreaControllerApi
   */
  public getPageSize(options?: RawAxiosRequestConfig) {
    return PersonalAreaControllerApiFp(this.configuration)
      .getPageSize(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting personal data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonalAreaControllerApi
   */
  public getPersonalData(options?: RawAxiosRequestConfig) {
    return PersonalAreaControllerApiFp(this.configuration)
      .getPersonalData(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonalAreaControllerApi
   */
  public getTheme(options?: RawAxiosRequestConfig) {
    return PersonalAreaControllerApiFp(this.configuration)
      .getTheme(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const EditPersonalDataEnglishLevelEnum = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const
export type EditPersonalDataEnglishLevelEnum =
  (typeof EditPersonalDataEnglishLevelEnum)[keyof typeof EditPersonalDataEnglishLevelEnum]
/**
 * @export
 */
export const EditPersonalDataCurrentSituationEnum = {
  Studying: 'STUDYING',
  Working: 'WORKING',
  StudiesAndWorking: 'STUDIES_AND_WORKING',
  Unemployed: 'UNEMPLOYED',
} as const
export type EditPersonalDataCurrentSituationEnum =
  (typeof EditPersonalDataCurrentSituationEnum)[keyof typeof EditPersonalDataCurrentSituationEnum]

/**
 * PresentControllerImplApi - axios parameter creator
 * @export
 */
export const PresentControllerImplApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {MessageStudentClick} messageStudentClick
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessageToQueue: async (
      messageStudentClick: MessageStudentClick,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'messageStudentClick' is not null or undefined
      assertParamExists(
        'sendMessageToQueue',
        'messageStudentClick',
        messageStudentClick
      )
      const localVarPath = `/api/v1/present/send`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        messageStudentClick,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PresentControllerImplApi - functional programming interface
 * @export
 */
export const PresentControllerImplApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    PresentControllerImplApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {MessageStudentClick} messageStudentClick
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendMessageToQueue(
      messageStudentClick: MessageStudentClick,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendMessageToQueue(
          messageStudentClick,
          options
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PresentControllerImplApi.sendMessageToQueue']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PresentControllerImplApi - factory interface
 * @export
 */
export const PresentControllerImplApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PresentControllerImplApiFp(configuration)
  return {
    /**
     *
     * @param {PresentControllerImplApiSendMessageToQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessageToQueue(
      requestParameters: PresentControllerImplApiSendMessageToQueueRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .sendMessageToQueue(requestParameters.messageStudentClick, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for sendMessageToQueue operation in PresentControllerImplApi.
 * @export
 * @interface PresentControllerImplApiSendMessageToQueueRequest
 */
export interface PresentControllerImplApiSendMessageToQueueRequest {
  /**
   *
   * @type {MessageStudentClick}
   * @memberof PresentControllerImplApiSendMessageToQueue
   */
  readonly messageStudentClick: MessageStudentClick
}

/**
 * PresentControllerImplApi - object-oriented interface
 * @export
 * @class PresentControllerImplApi
 * @extends {BaseAPI}
 */
export class PresentControllerImplApi extends BaseAPI {
  /**
   *
   * @param {PresentControllerImplApiSendMessageToQueueRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PresentControllerImplApi
   */
  public sendMessageToQueue(
    requestParameters: PresentControllerImplApiSendMessageToQueueRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PresentControllerImplApiFp(this.configuration)
      .sendMessageToQueue(requestParameters.messageStudentClick, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StatisticControllerApi - axios parameter creator
 * @export
 */
export const StatisticControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for getting Course By Student.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourseByStudent: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/statistic/getCourseByStudent`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting First Active Task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFirstActiveTask: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/statistic/getFirstActiveTask`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting Last Lesson Hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastLessonHours: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/statistic/getLastLessonHours`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting Quantity Lessons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuantityLessons: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/statistic/getQuantityLessons`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    integerResponseEntity: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/statistic/getHours`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StatisticControllerApi - functional programming interface
 * @export
 */
export const StatisticControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    StatisticControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for getting Course By Student.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCourseByStudent(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCourseByStudent(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatisticControllerApi.getCourseByStudent']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting First Active Task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFirstActiveTask(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFirstActiveTask(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatisticControllerApi.getFirstActiveTask']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting Last Lesson Hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLastLessonHours(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLastLessonHours(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatisticControllerApi.getLastLessonHours']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting Quantity Lessons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQuantityLessons(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQuantityLessons(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatisticControllerApi.getQuantityLessons']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async integerResponseEntity(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<IntegerResponseEntity200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.integerResponseEntity(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatisticControllerApi.integerResponseEntity']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * StatisticControllerApi - factory interface
 * @export
 */
export const StatisticControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StatisticControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for getting Course By Student.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCourseByStudent(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .getCourseByStudent(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting First Active Task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFirstActiveTask(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .getFirstActiveTask(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting Last Lesson Hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastLessonHours(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .getLastLessonHours(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting Quantity Lessons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuantityLessons(options?: RawAxiosRequestConfig): AxiosPromise<number> {
      return localVarFp
        .getQuantityLessons(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    integerResponseEntity(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<IntegerResponseEntity200Response> {
      return localVarFp
        .integerResponseEntity(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * StatisticControllerApi - object-oriented interface
 * @export
 * @class StatisticControllerApi
 * @extends {BaseAPI}
 */
export class StatisticControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for getting Course By Student.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticControllerApi
   */
  public getCourseByStudent(options?: RawAxiosRequestConfig) {
    return StatisticControllerApiFp(this.configuration)
      .getCourseByStudent(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting First Active Task.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticControllerApi
   */
  public getFirstActiveTask(options?: RawAxiosRequestConfig) {
    return StatisticControllerApiFp(this.configuration)
      .getFirstActiveTask(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting Last Lesson Hours.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticControllerApi
   */
  public getLastLessonHours(options?: RawAxiosRequestConfig) {
    return StatisticControllerApiFp(this.configuration)
      .getLastLessonHours(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting Quantity Lessons.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticControllerApi
   */
  public getQuantityLessons(options?: RawAxiosRequestConfig) {
    return StatisticControllerApiFp(this.configuration)
      .getQuantityLessons(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting hours.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticControllerApi
   */
  public integerResponseEntity(options?: RawAxiosRequestConfig) {
    return StatisticControllerApiFp(this.configuration)
      .integerResponseEntity(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TaskControllerApi - axios parameter creator
 * @export
 */
export const TaskControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The request for getting Last Lesson Hours.
     * @param {number} id ID by which the page is being generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePage: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('generatePage', 'id', id)
      const localVarPath = `/api/v1/tasks/generatePdf`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for getting tasks.
     * @param {number} page Page for pagination
     * @param {number} size Number of elements for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll: async (
      page: number,
      size: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists('getAll', 'page', page)
      // verify required parameter 'size' is not null or undefined
      assertParamExists('getAll', 'size', size)
      const localVarPath = `/api/v1/tasks/getAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary The request for get task.
     * @param {number} id ID by which the task is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById: async (
      id: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getById', 'id', id)
      const localVarPath = `/api/v1/tasks/getById`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TaskControllerApi - functional programming interface
 * @export
 */
export const TaskControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TaskControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The request for getting Last Lesson Hours.
     * @param {number} id ID by which the page is being generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generatePage(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generatePage(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.generatePage']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for getting tasks.
     * @param {number} page Page for pagination
     * @param {number} size Number of elements for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAll(
      page: number,
      size: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageStudentTask>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(
        page,
        size,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.getAll']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary The request for get task.
     * @param {number} id ID by which the task is being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getById(
      id: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTask>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getById(
        id,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaskControllerApi.getById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * TaskControllerApi - factory interface
 * @export
 */
export const TaskControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TaskControllerApiFp(configuration)
  return {
    /**
     *
     * @summary The request for getting Last Lesson Hours.
     * @param {TaskControllerApiGeneratePageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePage(
      requestParameters: TaskControllerApiGeneratePageRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .generatePage(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for getting tasks.
     * @param {TaskControllerApiGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      requestParameters: TaskControllerApiGetAllRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageStudentTask> {
      return localVarFp
        .getAll(requestParameters.page, requestParameters.size, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary The request for get task.
     * @param {TaskControllerApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getById(
      requestParameters: TaskControllerApiGetByIdRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentTask> {
      return localVarFp
        .getById(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for generatePage operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiGeneratePageRequest
 */
export interface TaskControllerApiGeneratePageRequest {
  /**
   * ID by which the page is being generated
   * @type {number}
   * @memberof TaskControllerApiGeneratePage
   */
  readonly id: number
}

/**
 * Request parameters for getAll operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiGetAllRequest
 */
export interface TaskControllerApiGetAllRequest {
  /**
   * Page for pagination
   * @type {number}
   * @memberof TaskControllerApiGetAll
   */
  readonly page: number

  /**
   * Number of elements for pagination
   * @type {number}
   * @memberof TaskControllerApiGetAll
   */
  readonly size: number
}

/**
 * Request parameters for getById operation in TaskControllerApi.
 * @export
 * @interface TaskControllerApiGetByIdRequest
 */
export interface TaskControllerApiGetByIdRequest {
  /**
   * ID by which the task is being searched
   * @type {number}
   * @memberof TaskControllerApiGetById
   */
  readonly id: number
}

/**
 * TaskControllerApi - object-oriented interface
 * @export
 * @class TaskControllerApi
 * @extends {BaseAPI}
 */
export class TaskControllerApi extends BaseAPI {
  /**
   *
   * @summary The request for getting Last Lesson Hours.
   * @param {TaskControllerApiGeneratePageRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public generatePage(
    requestParameters: TaskControllerApiGeneratePageRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .generatePage(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for getting tasks.
   * @param {TaskControllerApiGetAllRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public getAll(
    requestParameters: TaskControllerApiGetAllRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .getAll(requestParameters.page, requestParameters.size, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary The request for get task.
   * @param {TaskControllerApiGetByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskControllerApi
   */
  public getById(
    requestParameters: TaskControllerApiGetByIdRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TaskControllerApiFp(this.configuration)
      .getById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
